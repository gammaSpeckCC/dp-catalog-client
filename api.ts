/* tslint:disable */
/* eslint-disable */
/**
 * catalog-service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AccessRelationType = {
    Direct: 'Direct',
    Inherited: 'Inherited',
    Mixed: 'Mixed'
} as const;

export type AccessRelationType = typeof AccessRelationType[keyof typeof AccessRelationType];


/**
 * 
 * @export
 * @interface AccessResponseSchema
 */
export interface AccessResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof AccessResponseSchema
     */
    'transaction_id': string;
    /**
     * 
     * @type {string}
     * @memberof AccessResponseSchema
     */
    'resource_key': string;
    /**
     * 
     * @type {Actions}
     * @memberof AccessResponseSchema
     */
    'action': Actions;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Actions = {
    Initiated: 'INITIATED',
    Granted: 'GRANTED',
    Rejected: 'REJECTED',
    Revoked: 'REVOKED',
    Accepted: 'ACCEPTED',
    Cancelled: 'CANCELLED',
    Created: 'CREATED',
    Deleted: 'DELETED',
    Updated: 'UPDATED'
} as const;

export type Actions = typeof Actions[keyof typeof Actions];


/**
 * 
 * @export
 * @interface AddUserRequest
 */
export interface AddUserRequest {
    /**
     * 
     * @type {string}
     * @memberof AddUserRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface AddUserResponse
 */
export interface AddUserResponse {
    /**
     * 
     * @type {string}
     * @memberof AddUserResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AddUserResponse
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof AddUserResponse
     */
    'datacatalog_id': string;
}
/**
 * 
 * @export
 * @interface AddUserToGroupRequest
 */
export interface AddUserToGroupRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddUserToGroupRequest
     */
    'users': Array<string>;
}
/**
 * 
 * @export
 * @interface Analysis
 */
export interface Analysis {
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'analysis_id': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'analysis_url': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'updated_at': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AuditRecordsFileType = {
    Csv: 'CSV'
} as const;

export type AuditRecordsFileType = typeof AuditRecordsFileType[keyof typeof AuditRecordsFileType];


/**
 * 
 * @export
 * @interface AuthServiceResponse
 */
export interface AuthServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthServiceResponse
     */
    'status_code': string;
    /**
     * 
     * @type {object}
     * @memberof AuthServiceResponse
     */
    'content': object;
}
/**
 * 
 * @export
 * @interface ClassificationCreateSchema
 */
export interface ClassificationCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof ClassificationCreateSchema
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationCreateSchema
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationCreateSchema
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ClassificationSchema
 */
export interface ClassificationSchema {
    /**
     * 
     * @type {string}
     * @memberof ClassificationSchema
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationSchema
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationSchema
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface Column
 */
export interface Column {
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    'col_type': string;
    /**
     * 
     * @type {number}
     * @memberof Column
     */
    'sort_order': number;
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    'alias'?: string;
    /**
     * 
     * @type {Array<ColumnStat>}
     * @memberof Column
     */
    'stats'?: Array<ColumnStat>;
    /**
     * 
     * @type {GetClassificationSchema}
     * @memberof Column
     */
    'classification'?: GetClassificationSchema;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Column
     */
    'meta'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ColumnStat
 */
export interface ColumnStat {
    /**
     * 
     * @type {string}
     * @memberof ColumnStat
     */
    'stat_type': string;
    /**
     * 
     * @type {string}
     * @memberof ColumnStat
     */
    'stat_val'?: string;
    /**
     * 
     * @type {number}
     * @memberof ColumnStat
     */
    'start_epoch'?: number;
    /**
     * 
     * @type {number}
     * @memberof ColumnStat
     */
    'end_epoch'?: number;
}
/**
 * 
 * @export
 * @interface CreateDomainServiceAccountRequest
 */
export interface CreateDomainServiceAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDomainServiceAccountRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateRoleRequestSchema
 */
export interface CreateRoleRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleRequestSchema
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleRequestSchema
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateRoleResponseSchema
 */
export interface CreateRoleResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleResponseSchema
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleResponseSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleResponseSchema
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleResponseSchema
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateRoleResponseSchema
     */
    'users_count'?: number;
}
/**
 * 
 * @export
 * @interface CreateRuleRequestSchema
 */
export interface CreateRuleRequestSchema {
    /**
     * 
     * @type {ExtendedByKey}
     * @memberof CreateRuleRequestSchema
     */
    'extended_by': ExtendedByKey;
}
/**
 * 
 * @export
 * @interface DomainCreateSchema
 */
export interface DomainCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof DomainCreateSchema
     */
    'display_name': string;
    /**
     * 
     * @type {object}
     * @memberof DomainCreateSchema
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface DomainSchema
 */
export interface DomainSchema {
    /**
     * 
     * @type {string}
     * @memberof DomainSchema
     */
    'display_name': string;
    /**
     * 
     * @type {object}
     * @memberof DomainSchema
     */
    'meta'?: object;
    /**
     * 
     * @type {string}
     * @memberof DomainSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainSchema
     */
    'key': string;
    /**
     * 
     * @type {Visibility}
     * @memberof DomainSchema
     */
    'scope'?: Visibility;
}
/**
 * 
 * @export
 * @interface DomainSchemaListResponse
 */
export interface DomainSchemaListResponse {
    /**
     * 
     * @type {string}
     * @memberof DomainSchemaListResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof DomainSchemaListResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<SchemaResponse>}
     * @memberof DomainSchemaListResponse
     */
    'schemas'?: Array<SchemaResponse>;
}
/**
 * 
 * @export
 * @interface DomainTablesResponse
 */
export interface DomainTablesResponse {
    /**
     * 
     * @type {string}
     * @memberof DomainTablesResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainTablesResponse
     */
    'key': string;
    /**
     * 
     * @type {Array<Table>}
     * @memberof DomainTablesResponse
     */
    'tables'?: Array<Table>;
}
/**
 * 
 * @export
 * @interface DomainVisibilityUpdateRequestSchema
 */
export interface DomainVisibilityUpdateRequestSchema {
    /**
     * 
     * @type {Visibility}
     * @memberof DomainVisibilityUpdateRequestSchema
     */
    'scope': Visibility;
}
/**
 * 
 * @export
 * @interface EntityKey
 */
export interface EntityKey {
    /**
     * 
     * @type {string}
     * @memberof EntityKey
     */
    'key': string;
    /**
     * 
     * @type {EntityKindEnum}
     * @memberof EntityKey
     */
    'kind': EntityKindEnum;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const EntityKindEnum = {
    Table: 'Table',
    Schema: 'Schema',
    Classification: 'Classification'
} as const;

export type EntityKindEnum = typeof EntityKindEnum[keyof typeof EntityKindEnum];


/**
 * 
 * @export
 * @interface EventAPIToken
 */
export interface EventAPIToken {
    /**
     * 
     * @type {string}
     * @memberof EventAPIToken
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ExtendedByKey
 */
export interface ExtendedByKey {
    /**
     * 
     * @type {string}
     * @memberof ExtendedByKey
     */
    'key': string;
    /**
     * 
     * @type {ExtendedByKindEnum}
     * @memberof ExtendedByKey
     */
    'kind': ExtendedByKindEnum;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ExtendedByKindEnum = {
    User: 'User',
    Role: 'Role'
} as const;

export type ExtendedByKindEnum = typeof ExtendedByKindEnum[keyof typeof ExtendedByKindEnum];


/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof GenericResponse
     */
    'meta'?: object;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const GetAuditRecordsAction = {
    Download: 'download'
} as const;

export type GetAuditRecordsAction = typeof GetAuditRecordsAction[keyof typeof GetAuditRecordsAction];


/**
 * 
 * @export
 * @interface GetClassificationSchema
 */
export interface GetClassificationSchema {
    /**
     * 
     * @type {string}
     * @memberof GetClassificationSchema
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof GetClassificationSchema
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof GetClassificationSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetClassificationSchema
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof GetClassificationSchema
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetClassificationSchema
     */
    'total_pii'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetClassificationSchema
     */
    'total_roles'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetClassificationSchema
     */
    'total_users'?: number;
}
/**
 * 
 * @export
 * @interface GetDomainRoleSchema
 */
export interface GetDomainRoleSchema {
    /**
     * 
     * @type {string}
     * @memberof GetDomainRoleSchema
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainRoleSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainRoleSchema
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainRoleSchema
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetDomainRoleSchema
     */
    'users_count'?: number;
    /**
     * 
     * @type {DomainSchema}
     * @memberof GetDomainRoleSchema
     */
    'domain': DomainSchema;
}
/**
 * 
 * @export
 * @interface GetDomainSchema
 */
export interface GetDomainSchema {
    /**
     * 
     * @type {string}
     * @memberof GetDomainSchema
     */
    'display_name': string;
    /**
     * 
     * @type {object}
     * @memberof GetDomainSchema
     */
    'meta'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetDomainSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainSchema
     */
    'key': string;
    /**
     * 
     * @type {Visibility}
     * @memberof GetDomainSchema
     */
    'scope'?: Visibility;
    /**
     * 
     * @type {Array<Schema>}
     * @memberof GetDomainSchema
     */
    'schemas'?: Array<Schema>;
    /**
     * 
     * @type {number}
     * @memberof GetDomainSchema
     */
    'schema_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetDomainSchema
     */
    'table_count'?: number;
    /**
     * 
     * @type {UserLong}
     * @memberof GetDomainSchema
     */
    'owner'?: UserLong;
}
/**
 * 
 * @export
 * @interface GetFollowCountResponse
 */
export interface GetFollowCountResponse {
    /**
     * 
     * @type {string}
     * @memberof GetFollowCountResponse
     */
    'table_name': string;
    /**
     * 
     * @type {number}
     * @memberof GetFollowCountResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof GetFollowCountResponse
     */
    'users'?: Array<object>;
}
/**
 * 
 * @export
 * @interface GetResourceAccessResponseSchema
 */
export interface GetResourceAccessResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof GetResourceAccessResponseSchema
     */
    'transaction_id': string;
    /**
     * 
     * @type {number}
     * @memberof GetResourceAccessResponseSchema
     */
    'granted_on_timestamp_ms': number;
    /**
     * 
     * @type {TableBase}
     * @memberof GetResourceAccessResponseSchema
     */
    'resource'?: TableBase;
    /**
     * 
     * @type {string}
     * @memberof GetResourceAccessResponseSchema
     */
    'resource_key': string;
    /**
     * 
     * @type {User}
     * @memberof GetResourceAccessResponseSchema
     */
    'granted_by': User;
    /**
     * 
     * @type {User}
     * @memberof GetResourceAccessResponseSchema
     */
    'granted_to': User;
    /**
     * 
     * @type {AccessRelationType}
     * @memberof GetResourceAccessResponseSchema
     */
    'access_type': AccessRelationType;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof GetResourceAccessResponseSchema
     */
    'access_parents'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface GetResourceDescriptionResponse
 */
export interface GetResourceDescriptionResponse {
    /**
     * 
     * @type {string}
     * @memberof GetResourceDescriptionResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetResourceDescriptionResponse
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface GetResourceRequestResponseSchema
 */
export interface GetResourceRequestResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof GetResourceRequestResponseSchema
     */
    'request_id': string;
    /**
     * 
     * @type {number}
     * @memberof GetResourceRequestResponseSchema
     */
    'timestamp': number;
    /**
     * 
     * @type {TableBase}
     * @memberof GetResourceRequestResponseSchema
     */
    'resource'?: TableBase;
    /**
     * 
     * @type {string}
     * @memberof GetResourceRequestResponseSchema
     */
    'resource_key': string;
    /**
     * 
     * @type {User}
     * @memberof GetResourceRequestResponseSchema
     */
    'requested_by': User;
}
/**
 * 
 * @export
 * @interface GetRuleResponseSchema
 */
export interface GetRuleResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof GetRuleResponseSchema
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof GetRuleResponseSchema
     */
    'name': string;
    /**
     * 
     * @type {GetDomainSchema}
     * @memberof GetRuleResponseSchema
     */
    'domain'?: GetDomainSchema;
    /**
     * 
     * @type {Array<object>}
     * @memberof GetRuleResponseSchema
     */
    'entities'?: Array<object>;
    /**
     * 
     * @type {object}
     * @memberof GetRuleResponseSchema
     */
    'extended_by'?: object;
}
/**
 * 
 * @export
 * @interface GetTableMetadataSchema
 */
export interface GetTableMetadataSchema {
    /**
     * 
     * @type {string}
     * @memberof GetTableMetadataSchema
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetTableMetadataSchema
     */
    'required': boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof GetTableMetadataSchema
     */
    'values'?: Array<any>;
    /**
     * 
     * @type {TypeOfValues}
     * @memberof GetTableMetadataSchema
     */
    'type': TypeOfValues;
    /**
     * 
     * @type {string}
     * @memberof GetTableMetadataSchema
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableMetadataSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableMetadataSchema
     */
    'published_tag': string;
}
/**
 * 
 * @export
 * @interface GetTableVisualisationResponse
 */
export interface GetTableVisualisationResponse {
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'cloud': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'cloud_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'table': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'visualisation_type': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'quicksight_dataset_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'quicksight_source_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<Analysis>}
     * @memberof GetTableVisualisationResponse
     */
    'analysis'?: Array<Analysis>;
    /**
     * 
     * @type {string}
     * @memberof GetTableVisualisationResponse
     */
    'dataset_url': string;
}
/**
 * 
 * @export
 * @interface GetTableVisualizationResponse
 */
export interface GetTableVisualizationResponse {
    /**
     * 
     * @type {Array<GetTableVisualisationResponse>}
     * @memberof GetTableVisualizationResponse
     */
    'visualizations'?: Array<GetTableVisualisationResponse>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface InviteUserRequest
 */
export interface InviteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'role_key': string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'domain_key': string;
}
/**
 * 
 * @export
 * @interface ListClassificationResponseSchema
 */
export interface ListClassificationResponseSchema {
    /**
     * 
     * @type {Array<GetClassificationSchema>}
     * @memberof ListClassificationResponseSchema
     */
    'classifications'?: Array<GetClassificationSchema>;
}
/**
 * 
 * @export
 * @interface ListDomainResponseSchema
 */
export interface ListDomainResponseSchema {
    /**
     * 
     * @type {Array<GetDomainSchema>}
     * @memberof ListDomainResponseSchema
     */
    'domains'?: Array<GetDomainSchema>;
}
/**
 * 
 * @export
 * @interface ListDomainRulesResponse
 */
export interface ListDomainRulesResponse {
    /**
     * 
     * @type {Array<GetRuleResponseSchema>}
     * @memberof ListDomainRulesResponse
     */
    'rules'?: Array<GetRuleResponseSchema>;
    /**
     * 
     * @type {string}
     * @memberof ListDomainRulesResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ListDomainRulesResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ListOrgRoleResponseSchema
 */
export interface ListOrgRoleResponseSchema {
    /**
     * 
     * @type {Array<any>}
     * @memberof ListOrgRoleResponseSchema
     */
    'roles'?: Array<any>;
}
/**
 * 
 * @export
 * @interface ListRoleResponseSchema
 */
export interface ListRoleResponseSchema {
    /**
     * 
     * @type {Array<any>}
     * @memberof ListRoleResponseSchema
     */
    'roles'?: Array<any>;
}
/**
 * 
 * @export
 * @interface ListSchemasResponse
 */
export interface ListSchemasResponse {
    /**
     * 
     * @type {Array<SchemaResponse>}
     * @memberof ListSchemasResponse
     */
    'schemas'?: Array<SchemaResponse>;
}
/**
 * 
 * @export
 * @interface ListTableMetadataCreateSchema
 */
export interface ListTableMetadataCreateSchema {
    /**
     * 
     * @type {Array<TableMetadataCreateSchema>}
     * @memberof ListTableMetadataCreateSchema
     */
    'table_metadata_schema': Array<TableMetadataCreateSchema>;
}
/**
 * 
 * @export
 * @interface ListTableMetadataResponseSchema
 */
export interface ListTableMetadataResponseSchema {
    /**
     * 
     * @type {Array<GetTableMetadataSchema>}
     * @memberof ListTableMetadataResponseSchema
     */
    'table_metadata_schema'?: Array<GetTableMetadataSchema>;
}
/**
 * 
 * @export
 * @interface ListTableRequestsResponse
 */
export interface ListTableRequestsResponse {
    /**
     * 
     * @type {string}
     * @memberof ListTableRequestsResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ListTableRequestsResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<GetResourceRequestResponseSchema>}
     * @memberof ListTableRequestsResponse
     */
    'requests'?: Array<GetResourceRequestResponseSchema>;
    /**
     * 
     * @type {number}
     * @memberof ListTableRequestsResponse
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface ListUsersResponse
 */
export interface ListUsersResponse {
    /**
     * 
     * @type {Array<UserGetResponse>}
     * @memberof ListUsersResponse
     */
    'users'?: Array<UserGetResponse>;
}
/**
 * 
 * @export
 * @interface ListUsersTableHaveAccessResponse
 */
export interface ListUsersTableHaveAccessResponse {
    /**
     * 
     * @type {string}
     * @memberof ListUsersTableHaveAccessResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ListUsersTableHaveAccessResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<GetResourceAccessResponseSchema>}
     * @memberof ListUsersTableHaveAccessResponse
     */
    'accesses'?: Array<GetResourceAccessResponseSchema>;
    /**
     * 
     * @type {number}
     * @memberof ListUsersTableHaveAccessResponse
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface Org
 */
export interface Org {
    /**
     * 
     * @type {string}
     * @memberof Org
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Org
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof Org
     */
    'meta'?: object;
    /**
     * 
     * @type {object}
     * @memberof Org
     */
    'contactDetails'?: object;
    /**
     * 
     * @type {string}
     * @memberof Org
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Org
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PopularTablesResponse
 */
export interface PopularTablesResponse {
    /**
     * 
     * @type {Array<Table>}
     * @memberof PopularTablesResponse
     */
    'popular_tables': Array<Table>;
}
/**
 * 
 * @export
 * @interface Reader
 */
export interface Reader {
    /**
     * 
     * @type {User}
     * @memberof Reader
     */
    'user': User;
    /**
     * 
     * @type {number}
     * @memberof Reader
     */
    'read_count': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ResourceType = {
    Table: 'table',
    Dashboard: 'dashboard',
    Domain: 'domain',
    User: 'user'
} as const;

export type ResourceType = typeof ResourceType[keyof typeof ResourceType];


/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SchemaResponse
 */
export interface SchemaResponse {
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'published_tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'cluster': string;
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'database': string;
    /**
     * 
     * @type {Visibility}
     * @memberof SchemaResponse
     */
    'scope'?: Visibility;
    /**
     * 
     * @type {number}
     * @memberof SchemaResponse
     */
    'table_count'?: number;
    /**
     * 
     * @type {DomainSchema}
     * @memberof SchemaResponse
     */
    'domain'?: DomainSchema;
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'cloud_id'?: string;
}
/**
 * 
 * @export
 * @interface SchemaTableListResponse
 */
export interface SchemaTableListResponse {
    /**
     * 
     * @type {string}
     * @memberof SchemaTableListResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SchemaTableListResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Table>}
     * @memberof SchemaTableListResponse
     */
    'tables'?: Array<Table>;
}
/**
 * 
 * @export
 * @interface SchemaVisibilityUpdateRequestSchema
 */
export interface SchemaVisibilityUpdateRequestSchema {
    /**
     * 
     * @type {Visibility}
     * @memberof SchemaVisibilityUpdateRequestSchema
     */
    'scope': Visibility;
}
/**
 * 
 * @export
 * @interface SearchTableResponse
 */
export interface SearchTableResponse {
    /**
     * 
     * @type {Array<any>}
     * @memberof SearchTableResponse
     */
    'results'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof SearchTableResponse
     */
    'total_results'?: number;
}
/**
 * 
 * @export
 * @interface SearchUserResponse
 */
export interface SearchUserResponse {
    /**
     * 
     * @type {Array<any>}
     * @memberof SearchUserResponse
     */
    'results'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof SearchUserResponse
     */
    'total_results'?: number;
}
/**
 * 
 * @export
 * @interface Table
 */
export interface Table {
    /**
     * 
     * @type {Array<string>}
     * @memberof Table
     */
    'badges'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    'cluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    'database'?: string;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Table
     */
    'is_favorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Table
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Table
     */
    'is_owner'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Table
     */
    'snapshot_visible'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Table
     */
    'row_download_limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    'schema'?: string;
    /**
     * 
     * @type {number}
     * @memberof Table
     */
    'row_count'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Table
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {GetDomainSchema}
     * @memberof Table
     */
    'domain'?: GetDomainSchema;
    /**
     * 
     * @type {Visibility}
     * @memberof Table
     */
    'scope'?: Visibility;
    /**
     * 
     * @type {object}
     * @memberof Table
     */
    'meta'?: object;
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    'cloud_id'?: string;
    /**
     * 
     * @type {Array<Column>}
     * @memberof Table
     */
    'columns'?: Array<Column>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Table
     */
    'column_names'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Table
     */
    'column_aliases'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Table
     */
    'last_updated_timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof Table
     */
    'user_count'?: number;
    /**
     * 
     * @type {object}
     * @memberof Table
     */
    'highlight'?: object;
}
/**
 * 
 * @export
 * @interface TableAccessResponseSchema
 */
export interface TableAccessResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof TableAccessResponseSchema
     */
    'transaction_id': string;
}
/**
 * 
 * @export
 * @interface TableBase
 */
export interface TableBase {
    /**
     * 
     * @type {Array<string>}
     * @memberof TableBase
     */
    'badges'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TableBase
     */
    'cluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableBase
     */
    'database'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableBase
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TableBase
     */
    'is_favorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableBase
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableBase
     */
    'is_owner'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableBase
     */
    'snapshot_visible'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TableBase
     */
    'row_download_limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof TableBase
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableBase
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableBase
     */
    'schema'?: string;
    /**
     * 
     * @type {number}
     * @memberof TableBase
     */
    'row_count'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableBase
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {GetDomainSchema}
     * @memberof TableBase
     */
    'domain'?: GetDomainSchema;
    /**
     * 
     * @type {Visibility}
     * @memberof TableBase
     */
    'scope'?: Visibility;
    /**
     * 
     * @type {object}
     * @memberof TableBase
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface TableColumnClassificationUpdateSchema
 */
export interface TableColumnClassificationUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof TableColumnClassificationUpdateSchema
     */
    'classification_key': string;
}
/**
 * 
 * @export
 * @interface TableColumnDescUpdateSchema
 */
export interface TableColumnDescUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof TableColumnDescUpdateSchema
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface TableColumnMetaUpdateSchema
 */
export interface TableColumnMetaUpdateSchema {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TableColumnMetaUpdateSchema
     */
    'meta'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface TableColumnUpdateSchema
 */
export interface TableColumnUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof TableColumnUpdateSchema
     */
    'alias'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableColumnUpdateSchema
     */
    'literals'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TableDescriptionUpdateSchema
 */
export interface TableDescriptionUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof TableDescriptionUpdateSchema
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface TableLineageResponse
 */
export interface TableLineageResponse {
    /**
     * 
     * @type {string}
     * @memberof TableLineageResponse
     */
    'root_node_key': string;
    /**
     * 
     * @type {object}
     * @memberof TableLineageResponse
     */
    'forward_tree': object;
    /**
     * 
     * @type {object}
     * @memberof TableLineageResponse
     */
    'backward_tree': object;
    /**
     * 
     * @type {object}
     * @memberof TableLineageResponse
     */
    'node_mapper': object;
}
/**
 * 
 * @export
 * @interface TableLong
 */
export interface TableLong {
    /**
     * 
     * @type {Array<string>}
     * @memberof TableLong
     */
    'badges'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TableLong
     */
    'cluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableLong
     */
    'database'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableLong
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TableLong
     */
    'is_favorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableLong
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableLong
     */
    'is_owner'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableLong
     */
    'snapshot_visible'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TableLong
     */
    'row_download_limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof TableLong
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableLong
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableLong
     */
    'schema'?: string;
    /**
     * 
     * @type {number}
     * @memberof TableLong
     */
    'row_count'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableLong
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {GetDomainSchema}
     * @memberof TableLong
     */
    'domain'?: GetDomainSchema;
    /**
     * 
     * @type {Visibility}
     * @memberof TableLong
     */
    'scope'?: Visibility;
    /**
     * 
     * @type {object}
     * @memberof TableLong
     */
    'meta'?: object;
    /**
     * 
     * @type {string}
     * @memberof TableLong
     */
    'cloud_id'?: string;
    /**
     * 
     * @type {Array<Column>}
     * @memberof TableLong
     */
    'columns'?: Array<Column>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableLong
     */
    'column_names'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableLong
     */
    'column_aliases'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TableLong
     */
    'last_updated_timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof TableLong
     */
    'user_count'?: number;
    /**
     * 
     * @type {object}
     * @memberof TableLong
     */
    'highlight'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableLong
     */
    'column_descriptions'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TableLong
     */
    'total_usage'?: number;
    /**
     * 
     * @type {string}
     * @memberof TableLong
     */
    'schema_description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TableLong
     */
    'is_view'?: boolean;
    /**
     * 
     * @type {Array<Reader>}
     * @memberof TableLong
     */
    'readers'?: Array<Reader>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableLong
     */
    'owners'?: Array<string>;
    /**
     * 
     * @type {GetResourceRequestResponseSchema}
     * @memberof TableLong
     */
    'access_request'?: GetResourceRequestResponseSchema;
    /**
     * 
     * @type {ClassificationSchema}
     * @memberof TableLong
     */
    'classification'?: ClassificationSchema;
    /**
     * 
     * @type {TableType}
     * @memberof TableLong
     */
    'table_type'?: TableType;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableLong
     */
    'transformation_steps'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TableMetaUpdateSchema
 */
export interface TableMetaUpdateSchema {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TableMetaUpdateSchema
     */
    'meta'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface TableMetadataCreateSchema
 */
export interface TableMetadataCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof TableMetadataCreateSchema
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof TableMetadataCreateSchema
     */
    'required': boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof TableMetadataCreateSchema
     */
    'values'?: Array<any>;
    /**
     * 
     * @type {TypeOfValues}
     * @memberof TableMetadataCreateSchema
     */
    'type': TypeOfValues;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TableType = {
    Source: 'source',
    Transform: 'transform',
    Destination: 'destination'
} as const;

export type TableType = typeof TableType[keyof typeof TableType];


/**
 * 
 * @export
 * @interface TableUpdateSchema
 */
export interface TableUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof TableUpdateSchema
     */
    'alias'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TableUpdateSchema
     */
    'snapshot_visible'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TableUpdateSchema
     */
    'row_download_limit'?: number;
}
/**
 * 
 * @export
 * @interface TableVisibilityUpdateRequestSchema
 */
export interface TableVisibilityUpdateRequestSchema {
    /**
     * 
     * @type {Visibility}
     * @memberof TableVisibilityUpdateRequestSchema
     */
    'scope': Visibility;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TableVisualizationType = {
    Quicksight: 'QUICKSIGHT'
} as const;

export type TableVisualizationType = typeof TableVisualizationType[keyof typeof TableVisualizationType];


/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'tag_name': string;
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    'tag_count': number;
}
/**
 * 
 * @export
 * @interface TagsResponse
 */
export interface TagsResponse {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagsResponse
     */
    'tags'?: Array<Tag>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TypeOfValues = {
    Lov: 'LOV',
    String: 'STRING',
    Integer: 'INTEGER',
    Datetime: 'DATETIME'
} as const;

export type TypeOfValues = typeof TypeOfValues[keyof typeof TypeOfValues];


/**
 * 
 * @export
 * @interface UpdateResourceDescriptionResponse
 */
export interface UpdateResourceDescriptionResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceDescriptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateResourceTagResponse
 */
export interface UpdateResourceTagResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceTagResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateRuleRequestSchema
 */
export interface UpdateRuleRequestSchema {
    /**
     * 
     * @type {Array<EntityKey>}
     * @memberof UpdateRuleRequestSchema
     */
    'entities'?: Array<EntityKey>;
}
/**
 * 
 * @export
 * @interface UpdateUserRoleRequest
 */
export interface UpdateUserRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRoleRequest
     */
    'role_key': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'employee_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'github_username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'team_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'manager_email'?: string;
    /**
     * 
     * @type {object}
     * @memberof User
     */
    'highlight'?: object;
}
/**
 * 
 * @export
 * @interface UserGetResponse
 */
export interface UserGetResponse {
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'employee_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'github_username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserGetResponse
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'team_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'manager_email'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserGetResponse
     */
    'highlight'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'manager_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'slack_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserGetResponse
     */
    'other_key_values'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'profile_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'manager_fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'user_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserGetResponse
     */
    'invitation'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'invite_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'invited_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    'invite_accepted_on'?: string;
    /**
     * 
     * @type {GetDomainRoleSchema}
     * @memberof UserGetResponse
     */
    'role'?: GetDomainRoleSchema;
    /**
     * 
     * @type {UserTypeEnum}
     * @memberof UserGetResponse
     */
    'type'?: UserTypeEnum;
}
/**
 * 
 * @export
 * @interface UserLong
 */
export interface UserLong {
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'employee_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'github_username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserLong
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'team_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'manager_email'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserLong
     */
    'highlight'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'manager_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'slack_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserLong
     */
    'other_key_values'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'profile_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'manager_fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'user_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserLong
     */
    'invitation'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'invite_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'invited_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLong
     */
    'invite_accepted_on'?: string;
    /**
     * 
     * @type {GetDomainRoleSchema}
     * @memberof UserLong
     */
    'role'?: GetDomainRoleSchema;
    /**
     * 
     * @type {UserTypeEnum}
     * @memberof UserLong
     */
    'type'?: UserTypeEnum;
}
/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'employee_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'github_username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileResponse
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'team_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'manager_email'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserProfileResponse
     */
    'highlight'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'manager_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'slack_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserProfileResponse
     */
    'other_key_values'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'profile_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'manager_fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'user_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof UserProfileResponse
     */
    'invitation'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'invite_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'invited_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'invite_accepted_on'?: string;
    /**
     * 
     * @type {GetDomainRoleSchema}
     * @memberof UserProfileResponse
     */
    'role'?: GetDomainRoleSchema;
    /**
     * 
     * @type {UserTypeEnum}
     * @memberof UserProfileResponse
     */
    'type'?: UserTypeEnum;
    /**
     * 
     * @type {Array<Org>}
     * @memberof UserProfileResponse
     */
    'orgs'?: Array<Org>;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileResponse
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {Array<DomainSchema>}
     * @memberof UserProfileResponse
     */
    'owned_domains'?: Array<DomainSchema>;
    /**
     * 
     * @type {Array<DomainSchema>}
     * @memberof UserProfileResponse
     */
    'subscribed_domains'?: Array<DomainSchema>;
    /**
     * 
     * @type {Array<object>}
     * @memberof UserProfileResponse
     */
    'secrets'?: Array<object>;
}
/**
 * 
 * @export
 * @interface UserRelationDeleteResponse
 */
export interface UserRelationDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof UserRelationDeleteResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UserRelationPutResponse
 */
export interface UserRelationPutResponse {
    /**
     * 
     * @type {string}
     * @memberof UserRelationPutResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UserResourceGetResponse
 */
export interface UserResourceGetResponse {
    /**
     * 
     * @type {Array<any>}
     * @memberof UserResourceGetResponse
     */
    'dashboard'?: Array<any>;
    /**
     * 
     * @type {Array<Table>}
     * @memberof UserResourceGetResponse
     */
    'table'?: Array<Table>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const UserTypeEnum = {
    User: 'User',
    ServiceAccount: 'ServiceAccount'
} as const;

export type UserTypeEnum = typeof UserTypeEnum[keyof typeof UserTypeEnum];


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    'loc': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Visibility = {
    Default: 'default',
    Public: 'public',
    Private: 'private',
    Custom: 'custom'
} as const;

export type Visibility = typeof Visibility[keyof typeof Visibility];



/**
 * AuditsApi - axios parameter creator
 * @export
 */
export const AuditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Access Rules History
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRulesHistory: async (orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getAccessRulesHistory', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/audit/rules/history`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Access Rules Snapshot
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRulesSnapshot: async (orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getAccessRulesSnapshot', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/audit/rules/snapshot`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tables Query Log
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTablesQueryLog: async (orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getTablesQueryLog', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/audit/query/table`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditsApi - functional programming interface
 * @export
 */
export const AuditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Access Rules History
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRulesHistory(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRulesHistory(orgId, action, type, pageIndex, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Access Rules Snapshot
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRulesSnapshot(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRulesSnapshot(orgId, action, type, pageIndex, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tables Query Log
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTablesQueryLog(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTablesQueryLog(orgId, action, type, pageIndex, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditsApi - factory interface
 * @export
 */
export const AuditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Access Rules History
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRulesHistory(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: any): AxiosPromise<any> {
            return localVarFp.getAccessRulesHistory(orgId, action, type, pageIndex, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Access Rules Snapshot
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRulesSnapshot(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: any): AxiosPromise<any> {
            return localVarFp.getAccessRulesSnapshot(orgId, action, type, pageIndex, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tables Query Log
         * @param {string} orgId 
         * @param {GetAuditRecordsAction} [action] 
         * @param {AuditRecordsFileType} [type] 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTablesQueryLog(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: any): AxiosPromise<any> {
            return localVarFp.getTablesQueryLog(orgId, action, type, pageIndex, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditsApi - interface
 * @export
 * @interface AuditsApi
 */
export interface AuditsApiInterface {
    /**
     * 
     * @summary Get Access Rules History
     * @param {string} orgId 
     * @param {GetAuditRecordsAction} [action] 
     * @param {AuditRecordsFileType} [type] 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditsApiInterface
     */
    getAccessRulesHistory(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Access Rules Snapshot
     * @param {string} orgId 
     * @param {GetAuditRecordsAction} [action] 
     * @param {AuditRecordsFileType} [type] 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditsApiInterface
     */
    getAccessRulesSnapshot(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Tables Query Log
     * @param {string} orgId 
     * @param {GetAuditRecordsAction} [action] 
     * @param {AuditRecordsFileType} [type] 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditsApiInterface
     */
    getTablesQueryLog(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<any>;

}

/**
 * AuditsApi - object-oriented interface
 * @export
 * @class AuditsApi
 * @extends {BaseAPI}
 */
export class AuditsApi extends BaseAPI implements AuditsApiInterface {
    /**
     * 
     * @summary Get Access Rules History
     * @param {string} orgId 
     * @param {GetAuditRecordsAction} [action] 
     * @param {AuditRecordsFileType} [type] 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditsApi
     */
    public getAccessRulesHistory(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return AuditsApiFp(this.configuration).getAccessRulesHistory(orgId, action, type, pageIndex, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Access Rules Snapshot
     * @param {string} orgId 
     * @param {GetAuditRecordsAction} [action] 
     * @param {AuditRecordsFileType} [type] 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditsApi
     */
    public getAccessRulesSnapshot(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return AuditsApiFp(this.configuration).getAccessRulesSnapshot(orgId, action, type, pageIndex, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tables Query Log
     * @param {string} orgId 
     * @param {GetAuditRecordsAction} [action] 
     * @param {AuditRecordsFileType} [type] 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditsApi
     */
    public getTablesQueryLog(orgId: string, action?: GetAuditRecordsAction, type?: AuditRecordsFileType, pageIndex?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return AuditsApiFp(this.configuration).getTablesQueryLog(orgId, action, type, pageIndex, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClassificationApi - axios parameter creator
 * @export
 */
export const ClassificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Classification
         * @param {string} orgId 
         * @param {ClassificationCreateSchema} classificationCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassification: async (orgId: string, classificationCreateSchema: ClassificationCreateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createClassification', 'orgId', orgId)
            // verify required parameter 'classificationCreateSchema' is not null or undefined
            assertParamExists('createClassification', 'classificationCreateSchema', classificationCreateSchema)
            const localVarPath = `/v1/org/{org_id}/classification`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classificationCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List All Classifications
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllClassifications: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAllClassifications', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/classification`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassificationApi - functional programming interface
 * @export
 */
export const ClassificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Classification
         * @param {string} orgId 
         * @param {ClassificationCreateSchema} classificationCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClassification(orgId: string, classificationCreateSchema: ClassificationCreateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClassificationSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClassification(orgId, classificationCreateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List All Classifications
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllClassifications(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListClassificationResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllClassifications(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClassificationApi - factory interface
 * @export
 */
export const ClassificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Classification
         * @param {string} orgId 
         * @param {ClassificationCreateSchema} classificationCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassification(orgId: string, classificationCreateSchema: ClassificationCreateSchema, options?: any): AxiosPromise<GetClassificationSchema> {
            return localVarFp.createClassification(orgId, classificationCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List All Classifications
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllClassifications(orgId: string, options?: any): AxiosPromise<ListClassificationResponseSchema> {
            return localVarFp.listAllClassifications(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassificationApi - interface
 * @export
 * @interface ClassificationApi
 */
export interface ClassificationApiInterface {
    /**
     * 
     * @summary Create Classification
     * @param {string} orgId 
     * @param {ClassificationCreateSchema} classificationCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApiInterface
     */
    createClassification(orgId: string, classificationCreateSchema: ClassificationCreateSchema, options?: AxiosRequestConfig): AxiosPromise<GetClassificationSchema>;

    /**
     * 
     * @summary List All Classifications
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApiInterface
     */
    listAllClassifications(orgId: string, options?: AxiosRequestConfig): AxiosPromise<ListClassificationResponseSchema>;

}

/**
 * ClassificationApi - object-oriented interface
 * @export
 * @class ClassificationApi
 * @extends {BaseAPI}
 */
export class ClassificationApi extends BaseAPI implements ClassificationApiInterface {
    /**
     * 
     * @summary Create Classification
     * @param {string} orgId 
     * @param {ClassificationCreateSchema} classificationCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApi
     */
    public createClassification(orgId: string, classificationCreateSchema: ClassificationCreateSchema, options?: AxiosRequestConfig) {
        return ClassificationApiFp(this.configuration).createClassification(orgId, classificationCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List All Classifications
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApi
     */
    public listAllClassifications(orgId: string, options?: AxiosRequestConfig) {
        return ClassificationApiFp(this.configuration).listAllClassifications(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks that we are connected to database and return service information
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks that we are connected to database and return service information
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Checks that we are connected to database and return service information
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any): AxiosPromise<any> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Checks that we are connected to database and return service information
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    healthCheck(options?: AxiosRequestConfig): AxiosPromise<any>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Checks that we are connected to database and return service information
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DomainApi - axios parameter creator
 * @export
 */
export const DomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Entities To Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntitiesToRule: async (orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addEntitiesToRule', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('addEntitiesToRule', 'domainName', domainName)
            // verify required parameter 'ruleName' is not null or undefined
            assertParamExists('addEntitiesToRule', 'ruleName', ruleName)
            // verify required parameter 'updateRuleRequestSchema' is not null or undefined
            assertParamExists('addEntitiesToRule', 'updateRuleRequestSchema', updateRuleRequestSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/rule/{rule_name}/entity`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"rule_name"}}`, encodeURIComponent(String(ruleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRuleRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Member To Domain
         * @param {string} member 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToDomain: async (member: string, orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'member' is not null or undefined
            assertParamExists('addMemberToDomain', 'member', member)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addMemberToDomain', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('addMemberToDomain', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/member/{member}`
                .replace(`{${"member"}}`, encodeURIComponent(String(member)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Schema To Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSchemaToDomain: async (orgId: string, domainName: string, cluster: string, schemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addSchemaToDomain', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('addSchemaToDomain', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('addSchemaToDomain', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('addSchemaToDomain', 'schemaName', schemaName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Domain
         * @param {string} orgId 
         * @param {DomainCreateSchema} domainCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: async (orgId: string, domainCreateSchema: DomainCreateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createDomain', 'orgId', orgId)
            // verify required parameter 'domainCreateSchema' is not null or undefined
            assertParamExists('createDomain', 'domainCreateSchema', domainCreateSchema)
            const localVarPath = `/v1/org/{org_id}/domain`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Domain Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {CreateRuleRequestSchema} createRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainRule: async (orgId: string, domainName: string, createRuleRequestSchema: CreateRuleRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createDomainRule', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('createDomainRule', 'domainName', domainName)
            // verify required parameter 'createRuleRequestSchema' is not null or undefined
            assertParamExists('createDomainRule', 'createRuleRequestSchema', createRuleRequestSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/rule`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRuleRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Service Account User
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {CreateDomainServiceAccountRequest} createDomainServiceAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccountUser: async (orgId: string, domainName: string, createDomainServiceAccountRequest: CreateDomainServiceAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createServiceAccountUser', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('createServiceAccountUser', 'domainName', domainName)
            // verify required parameter 'createDomainServiceAccountRequest' is not null or undefined
            assertParamExists('createServiceAccountUser', 'createDomainServiceAccountRequest', createDomainServiceAccountRequest)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/serviceAccount`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDomainServiceAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Domain Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainRule: async (orgId: string, domainName: string, ruleName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteDomainRule', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('deleteDomainRule', 'domainName', domainName)
            // verify required parameter 'ruleName' is not null or undefined
            assertParamExists('deleteDomainRule', 'ruleName', ruleName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/rule/{rule_name}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"rule_name"}}`, encodeURIComponent(String(ruleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: async (orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDomain', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getDomain', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Domain Rule
         * @param {string} ruleName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainRule: async (ruleName: string, orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleName' is not null or undefined
            assertParamExists('getDomainRule', 'ruleName', ruleName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDomainRule', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getDomainRule', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/rule/{rule_name}`
                .replace(`{${"rule_name"}}`, encodeURIComponent(String(ruleName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List All Domain Schemas
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDomainSchemas: async (orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAllDomainSchemas', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('listAllDomainSchemas', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/schema`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List All Domains
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDomains: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAllDomains', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/domain`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Domain Role Users
         * @param {string} roleName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainRoleUsers: async (roleName: string, orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('listDomainRoleUsers', 'roleName', roleName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDomainRoleUsers', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('listDomainRoleUsers', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/role/{role_name}/user`
                .replace(`{${"role_name"}}`, encodeURIComponent(String(roleName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Domain Roles
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainRoles: async (orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDomainRoles', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('listDomainRoles', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/role`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Domain Rules
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainRules: async (orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDomainRules', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('listDomainRules', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/rule`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Domain Tables
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {boolean} [includeUserCount] 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainTables: async (orgId: string, domainName: string, includeUserCount?: boolean, pageIndex?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDomainTables', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('listDomainTables', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/table`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (includeUserCount !== undefined) {
                localVarQueryParameter['include_user_count'] = includeUserCount;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Domain Owner
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDomainOwner: async (orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('removeDomainOwner', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('removeDomainOwner', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/owner`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Entities From Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntitiesFromRule: async (orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('removeEntitiesFromRule', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('removeEntitiesFromRule', 'domainName', domainName)
            // verify required parameter 'ruleName' is not null or undefined
            assertParamExists('removeEntitiesFromRule', 'ruleName', ruleName)
            // verify required parameter 'updateRuleRequestSchema' is not null or undefined
            assertParamExists('removeEntitiesFromRule', 'updateRuleRequestSchema', updateRuleRequestSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/rule/{rule_name}/entity`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"rule_name"}}`, encodeURIComponent(String(ruleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRuleRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Member To Domain
         * @param {string} member 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemberToDomain: async (member: string, orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'member' is not null or undefined
            assertParamExists('removeMemberToDomain', 'member', member)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('removeMemberToDomain', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('removeMemberToDomain', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/member/{member}`
                .replace(`{${"member"}}`, encodeURIComponent(String(member)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Schema From Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSchemaFromDomain: async (orgId: string, domainName: string, cluster: string, schemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('removeSchemaFromDomain', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('removeSchemaFromDomain', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('removeSchemaFromDomain', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('removeSchemaFromDomain', 'schemaName', schemaName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Domain Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDomainOwner: async (owner: string, orgId: string, domainName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('setDomainOwner', 'owner', owner)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('setDomainOwner', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('setDomainOwner', 'domainName', domainName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/owner/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Domain Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {DomainVisibilityUpdateRequestSchema} domainVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDomainVisibility: async (orgId: string, domainName: string, domainVisibilityUpdateRequestSchema: DomainVisibilityUpdateRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('setDomainVisibility', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('setDomainVisibility', 'domainName', domainName)
            // verify required parameter 'domainVisibilityUpdateRequestSchema' is not null or undefined
            assertParamExists('setDomainVisibility', 'domainVisibilityUpdateRequestSchema', domainVisibilityUpdateRequestSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/visibility`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainVisibilityUpdateRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainApi - functional programming interface
 * @export
 */
export const DomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Entities To Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntitiesToRule(orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRuleResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntitiesToRule(orgId, domainName, ruleName, updateRuleRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Member To Domain
         * @param {string} member 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberToDomain(member: string, orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberToDomain(member, orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Schema To Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSchemaToDomain(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSchemaToDomain(orgId, domainName, cluster, schemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Domain
         * @param {string} orgId 
         * @param {DomainCreateSchema} domainCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomain(orgId: string, domainCreateSchema: DomainCreateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomain(orgId, domainCreateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Domain Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {CreateRuleRequestSchema} createRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainRule(orgId: string, domainName: string, createRuleRequestSchema: CreateRuleRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRuleResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainRule(orgId, domainName, createRuleRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Service Account User
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {CreateDomainServiceAccountRequest} createDomainServiceAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAccountUser(orgId: string, domainName: string, createDomainServiceAccountRequest: CreateDomainServiceAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAccountUser(orgId, domainName, createDomainServiceAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Domain Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainRule(orgId: string, domainName: string, ruleName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainRule(orgId, domainName, ruleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomain(orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomain(orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Domain Rule
         * @param {string} ruleName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainRule(ruleName: string, orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRuleResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainRule(ruleName, orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List All Domain Schemas
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllDomainSchemas(orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainSchemaListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllDomainSchemas(orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List All Domains
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllDomains(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDomainResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllDomains(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Domain Role Users
         * @param {string} roleName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDomainRoleUsers(roleName: string, orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDomainRoleUsers(roleName, orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Domain Roles
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDomainRoles(orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRoleResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDomainRoles(orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Domain Rules
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDomainRules(orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDomainRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDomainRules(orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Domain Tables
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {boolean} [includeUserCount] 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDomainTables(orgId: string, domainName: string, includeUserCount?: boolean, pageIndex?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainTablesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDomainTables(orgId, domainName, includeUserCount, pageIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Domain Owner
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDomainOwner(orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDomainOwner(orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Entities From Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEntitiesFromRule(orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRuleResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEntitiesFromRule(orgId, domainName, ruleName, updateRuleRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Member To Domain
         * @param {string} member 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMemberToDomain(member: string, orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMemberToDomain(member, orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Schema From Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSchemaFromDomain(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSchemaFromDomain(orgId, domainName, cluster, schemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Domain Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDomainOwner(owner: string, orgId: string, domainName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDomainOwner(owner, orgId, domainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Domain Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {DomainVisibilityUpdateRequestSchema} domainVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDomainVisibility(orgId: string, domainName: string, domainVisibilityUpdateRequestSchema: DomainVisibilityUpdateRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDomainVisibility(orgId, domainName, domainVisibilityUpdateRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DomainApi - factory interface
 * @export
 */
export const DomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Entities To Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntitiesToRule(orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options?: any): AxiosPromise<GetRuleResponseSchema> {
            return localVarFp.addEntitiesToRule(orgId, domainName, ruleName, updateRuleRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Member To Domain
         * @param {string} member 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToDomain(member: string, orgId: string, domainName: string, options?: any): AxiosPromise<any> {
            return localVarFp.addMemberToDomain(member, orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Schema To Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSchemaToDomain(orgId: string, domainName: string, cluster: string, schemaName: string, options?: any): AxiosPromise<GetDomainSchema> {
            return localVarFp.addSchemaToDomain(orgId, domainName, cluster, schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Domain
         * @param {string} orgId 
         * @param {DomainCreateSchema} domainCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(orgId: string, domainCreateSchema: DomainCreateSchema, options?: any): AxiosPromise<GetDomainSchema> {
            return localVarFp.createDomain(orgId, domainCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Domain Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {CreateRuleRequestSchema} createRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainRule(orgId: string, domainName: string, createRuleRequestSchema: CreateRuleRequestSchema, options?: any): AxiosPromise<GetRuleResponseSchema> {
            return localVarFp.createDomainRule(orgId, domainName, createRuleRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Service Account User
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {CreateDomainServiceAccountRequest} createDomainServiceAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccountUser(orgId: string, domainName: string, createDomainServiceAccountRequest: CreateDomainServiceAccountRequest, options?: any): AxiosPromise<UserProfileResponse> {
            return localVarFp.createServiceAccountUser(orgId, domainName, createDomainServiceAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Domain Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainRule(orgId: string, domainName: string, ruleName: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteDomainRule(orgId, domainName, ruleName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(orgId: string, domainName: string, options?: any): AxiosPromise<GetDomainSchema> {
            return localVarFp.getDomain(orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Domain Rule
         * @param {string} ruleName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainRule(ruleName: string, orgId: string, domainName: string, options?: any): AxiosPromise<GetRuleResponseSchema> {
            return localVarFp.getDomainRule(ruleName, orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List All Domain Schemas
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDomainSchemas(orgId: string, domainName: string, options?: any): AxiosPromise<DomainSchemaListResponse> {
            return localVarFp.listAllDomainSchemas(orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List All Domains
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllDomains(orgId: string, options?: any): AxiosPromise<ListDomainResponseSchema> {
            return localVarFp.listAllDomains(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Domain Role Users
         * @param {string} roleName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainRoleUsers(roleName: string, orgId: string, domainName: string, options?: any): AxiosPromise<ListUsersResponse> {
            return localVarFp.listDomainRoleUsers(roleName, orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Domain Roles
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainRoles(orgId: string, domainName: string, options?: any): AxiosPromise<ListRoleResponseSchema> {
            return localVarFp.listDomainRoles(orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Domain Rules
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainRules(orgId: string, domainName: string, options?: any): AxiosPromise<ListDomainRulesResponse> {
            return localVarFp.listDomainRules(orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Domain Tables
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {boolean} [includeUserCount] 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainTables(orgId: string, domainName: string, includeUserCount?: boolean, pageIndex?: number, options?: any): AxiosPromise<DomainTablesResponse> {
            return localVarFp.listDomainTables(orgId, domainName, includeUserCount, pageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Domain Owner
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDomainOwner(orgId: string, domainName: string, options?: any): AxiosPromise<GetDomainSchema> {
            return localVarFp.removeDomainOwner(orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Entities From Rule
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} ruleName 
         * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntitiesFromRule(orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options?: any): AxiosPromise<GetRuleResponseSchema> {
            return localVarFp.removeEntitiesFromRule(orgId, domainName, ruleName, updateRuleRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Member To Domain
         * @param {string} member 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemberToDomain(member: string, orgId: string, domainName: string, options?: any): AxiosPromise<any> {
            return localVarFp.removeMemberToDomain(member, orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Schema From Domain
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSchemaFromDomain(orgId: string, domainName: string, cluster: string, schemaName: string, options?: any): AxiosPromise<GetDomainSchema> {
            return localVarFp.removeSchemaFromDomain(orgId, domainName, cluster, schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Domain Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDomainOwner(owner: string, orgId: string, domainName: string, options?: any): AxiosPromise<GetDomainSchema> {
            return localVarFp.setDomainOwner(owner, orgId, domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Domain Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {DomainVisibilityUpdateRequestSchema} domainVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDomainVisibility(orgId: string, domainName: string, domainVisibilityUpdateRequestSchema: DomainVisibilityUpdateRequestSchema, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.setDomainVisibility(orgId, domainName, domainVisibilityUpdateRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainApi - interface
 * @export
 * @interface DomainApi
 */
export interface DomainApiInterface {
    /**
     * 
     * @summary Add Entities To Rule
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} ruleName 
     * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    addEntitiesToRule(orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options?: AxiosRequestConfig): AxiosPromise<GetRuleResponseSchema>;

    /**
     * 
     * @summary Add Member To Domain
     * @param {string} member 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    addMemberToDomain(member: string, orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Add Schema To Domain
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    addSchemaToDomain(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig): AxiosPromise<GetDomainSchema>;

    /**
     * 
     * @summary Create Domain
     * @param {string} orgId 
     * @param {DomainCreateSchema} domainCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    createDomain(orgId: string, domainCreateSchema: DomainCreateSchema, options?: AxiosRequestConfig): AxiosPromise<GetDomainSchema>;

    /**
     * 
     * @summary Create Domain Rule
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {CreateRuleRequestSchema} createRuleRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    createDomainRule(orgId: string, domainName: string, createRuleRequestSchema: CreateRuleRequestSchema, options?: AxiosRequestConfig): AxiosPromise<GetRuleResponseSchema>;

    /**
     * 
     * @summary Create Service Account User
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {CreateDomainServiceAccountRequest} createDomainServiceAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    createServiceAccountUser(orgId: string, domainName: string, createDomainServiceAccountRequest: CreateDomainServiceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileResponse>;

    /**
     * 
     * @summary Delete Domain Rule
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} ruleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    deleteDomainRule(orgId: string, domainName: string, ruleName: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Domain
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    getDomain(orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<GetDomainSchema>;

    /**
     * 
     * @summary Get Domain Rule
     * @param {string} ruleName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    getDomainRule(ruleName: string, orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<GetRuleResponseSchema>;

    /**
     * 
     * @summary List All Domain Schemas
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    listAllDomainSchemas(orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<DomainSchemaListResponse>;

    /**
     * 
     * @summary List All Domains
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    listAllDomains(orgId: string, options?: AxiosRequestConfig): AxiosPromise<ListDomainResponseSchema>;

    /**
     * 
     * @summary List Domain Role Users
     * @param {string} roleName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    listDomainRoleUsers(roleName: string, orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<ListUsersResponse>;

    /**
     * 
     * @summary List Domain Roles
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    listDomainRoles(orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<ListRoleResponseSchema>;

    /**
     * 
     * @summary List Domain Rules
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    listDomainRules(orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<ListDomainRulesResponse>;

    /**
     * 
     * @summary List Domain Tables
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {boolean} [includeUserCount] 
     * @param {number} [pageIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    listDomainTables(orgId: string, domainName: string, includeUserCount?: boolean, pageIndex?: number, options?: AxiosRequestConfig): AxiosPromise<DomainTablesResponse>;

    /**
     * 
     * @summary Remove Domain Owner
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    removeDomainOwner(orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<GetDomainSchema>;

    /**
     * 
     * @summary Remove Entities From Rule
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} ruleName 
     * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    removeEntitiesFromRule(orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options?: AxiosRequestConfig): AxiosPromise<GetRuleResponseSchema>;

    /**
     * 
     * @summary Remove Member To Domain
     * @param {string} member 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    removeMemberToDomain(member: string, orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Remove Schema From Domain
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    removeSchemaFromDomain(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig): AxiosPromise<GetDomainSchema>;

    /**
     * 
     * @summary Set Domain Owner
     * @param {string} owner 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    setDomainOwner(owner: string, orgId: string, domainName: string, options?: AxiosRequestConfig): AxiosPromise<GetDomainSchema>;

    /**
     * 
     * @summary Set Domain Visibility
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {DomainVisibilityUpdateRequestSchema} domainVisibilityUpdateRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApiInterface
     */
    setDomainVisibility(orgId: string, domainName: string, domainVisibilityUpdateRequestSchema: DomainVisibilityUpdateRequestSchema, options?: AxiosRequestConfig): AxiosPromise<GenericResponse>;

}

/**
 * DomainApi - object-oriented interface
 * @export
 * @class DomainApi
 * @extends {BaseAPI}
 */
export class DomainApi extends BaseAPI implements DomainApiInterface {
    /**
     * 
     * @summary Add Entities To Rule
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} ruleName 
     * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public addEntitiesToRule(orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).addEntitiesToRule(orgId, domainName, ruleName, updateRuleRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Member To Domain
     * @param {string} member 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public addMemberToDomain(member: string, orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).addMemberToDomain(member, orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Schema To Domain
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public addSchemaToDomain(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).addSchemaToDomain(orgId, domainName, cluster, schemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Domain
     * @param {string} orgId 
     * @param {DomainCreateSchema} domainCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public createDomain(orgId: string, domainCreateSchema: DomainCreateSchema, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).createDomain(orgId, domainCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Domain Rule
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {CreateRuleRequestSchema} createRuleRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public createDomainRule(orgId: string, domainName: string, createRuleRequestSchema: CreateRuleRequestSchema, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).createDomainRule(orgId, domainName, createRuleRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Service Account User
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {CreateDomainServiceAccountRequest} createDomainServiceAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public createServiceAccountUser(orgId: string, domainName: string, createDomainServiceAccountRequest: CreateDomainServiceAccountRequest, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).createServiceAccountUser(orgId, domainName, createDomainServiceAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Domain Rule
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} ruleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public deleteDomainRule(orgId: string, domainName: string, ruleName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).deleteDomainRule(orgId, domainName, ruleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Domain
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public getDomain(orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).getDomain(orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Domain Rule
     * @param {string} ruleName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public getDomainRule(ruleName: string, orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).getDomainRule(ruleName, orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List All Domain Schemas
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public listAllDomainSchemas(orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).listAllDomainSchemas(orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List All Domains
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public listAllDomains(orgId: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).listAllDomains(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Domain Role Users
     * @param {string} roleName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public listDomainRoleUsers(roleName: string, orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).listDomainRoleUsers(roleName, orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Domain Roles
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public listDomainRoles(orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).listDomainRoles(orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Domain Rules
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public listDomainRules(orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).listDomainRules(orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Domain Tables
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {boolean} [includeUserCount] 
     * @param {number} [pageIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public listDomainTables(orgId: string, domainName: string, includeUserCount?: boolean, pageIndex?: number, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).listDomainTables(orgId, domainName, includeUserCount, pageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Domain Owner
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public removeDomainOwner(orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).removeDomainOwner(orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Entities From Rule
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} ruleName 
     * @param {UpdateRuleRequestSchema} updateRuleRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public removeEntitiesFromRule(orgId: string, domainName: string, ruleName: string, updateRuleRequestSchema: UpdateRuleRequestSchema, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).removeEntitiesFromRule(orgId, domainName, ruleName, updateRuleRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Member To Domain
     * @param {string} member 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public removeMemberToDomain(member: string, orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).removeMemberToDomain(member, orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Schema From Domain
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public removeSchemaFromDomain(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).removeSchemaFromDomain(orgId, domainName, cluster, schemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Domain Owner
     * @param {string} owner 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public setDomainOwner(owner: string, orgId: string, domainName: string, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).setDomainOwner(owner, orgId, domainName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Domain Visibility
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {DomainVisibilityUpdateRequestSchema} domainVisibilityUpdateRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public setDomainVisibility(orgId: string, domainName: string, domainVisibilityUpdateRequestSchema: DomainVisibilityUpdateRequestSchema, options?: AxiosRequestConfig) {
        return DomainApiFp(this.configuration).setDomainVisibility(orgId, domainName, domainVisibilityUpdateRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Event Api Token
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventApiToken: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getEventApiToken', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/event/token`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Event Api Token
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventApiToken(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAPIToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventApiToken(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Event Api Token
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventApiToken(orgId: string, options?: any): AxiosPromise<EventAPIToken> {
            return localVarFp.getEventApiToken(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - interface
 * @export
 * @interface EventApi
 */
export interface EventApiInterface {
    /**
     * 
     * @summary Get Event Api Token
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApiInterface
     */
    getEventApiToken(orgId: string, options?: AxiosRequestConfig): AxiosPromise<EventAPIToken>;

}

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI implements EventApiInterface {
    /**
     * 
     * @summary Get Event Api Token
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventApiToken(orgId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventApiToken(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Federate Url
         * @param {string} cloudId 
         * @param {string} destination 
         * @param {string} [assumeRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        federateUrl: async (cloudId: string, destination: string, assumeRole?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudId' is not null or undefined
            assertParamExists('federateUrl', 'cloudId', cloudId)
            // verify required parameter 'destination' is not null or undefined
            assertParamExists('federateUrl', 'destination', destination)
            const localVarPath = `/v1/federate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (cloudId !== undefined) {
                localVarQueryParameter['cloud_id'] = cloudId;
            }

            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }

            if (assumeRole !== undefined) {
                localVarQueryParameter['assume_role'] = assumeRole;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Popular Tables
         * @param {string} orgId 
         * @param {number} [pageIndex] 
         * @param {string} [userId] 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularTables: async (orgId: string, pageIndex?: number, userId?: string, includeFavorites?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPopularTables', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/tables/popular`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (includeFavorites !== undefined) {
                localVarQueryParameter['include_favorites'] = includeFavorites;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Support Token
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportToken: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getSupportToken', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/support/token`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tags
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getTags', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/tags`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeneralApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Federate Url
         * @param {string} cloudId 
         * @param {string} destination 
         * @param {string} [assumeRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async federateUrl(cloudId: string, destination: string, assumeRole?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.federateUrl(cloudId, destination, assumeRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Popular Tables
         * @param {string} orgId 
         * @param {number} [pageIndex] 
         * @param {string} [userId] 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPopularTables(orgId: string, pageIndex?: number, userId?: string, includeFavorites?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PopularTablesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPopularTables(orgId, pageIndex, userId, includeFavorites, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Support Token
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportToken(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportToken(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tags
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralApiFp(configuration)
    return {
        /**
         * 
         * @summary Federate Url
         * @param {string} cloudId 
         * @param {string} destination 
         * @param {string} [assumeRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        federateUrl(cloudId: string, destination: string, assumeRole?: string, options?: any): AxiosPromise<void> {
            return localVarFp.federateUrl(cloudId, destination, assumeRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Popular Tables
         * @param {string} orgId 
         * @param {number} [pageIndex] 
         * @param {string} [userId] 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularTables(orgId: string, pageIndex?: number, userId?: string, includeFavorites?: boolean, options?: any): AxiosPromise<PopularTablesResponse> {
            return localVarFp.getPopularTables(orgId, pageIndex, userId, includeFavorites, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Support Token
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportToken(orgId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getSupportToken(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tags
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(orgId: string, options?: any): AxiosPromise<TagsResponse> {
            return localVarFp.getTags(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeneralApi - interface
 * @export
 * @interface GeneralApi
 */
export interface GeneralApiInterface {
    /**
     * 
     * @summary Federate Url
     * @param {string} cloudId 
     * @param {string} destination 
     * @param {string} [assumeRole] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApiInterface
     */
    federateUrl(cloudId: string, destination: string, assumeRole?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get Popular Tables
     * @param {string} orgId 
     * @param {number} [pageIndex] 
     * @param {string} [userId] 
     * @param {boolean} [includeFavorites] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApiInterface
     */
    getPopularTables(orgId: string, pageIndex?: number, userId?: string, includeFavorites?: boolean, options?: AxiosRequestConfig): AxiosPromise<PopularTablesResponse>;

    /**
     * 
     * @summary Get Support Token
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApiInterface
     */
    getSupportToken(orgId: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Tags
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApiInterface
     */
    getTags(orgId: string, options?: AxiosRequestConfig): AxiosPromise<TagsResponse>;

}

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI implements GeneralApiInterface {
    /**
     * 
     * @summary Federate Url
     * @param {string} cloudId 
     * @param {string} destination 
     * @param {string} [assumeRole] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public federateUrl(cloudId: string, destination: string, assumeRole?: string, options?: AxiosRequestConfig) {
        return GeneralApiFp(this.configuration).federateUrl(cloudId, destination, assumeRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Popular Tables
     * @param {string} orgId 
     * @param {number} [pageIndex] 
     * @param {string} [userId] 
     * @param {boolean} [includeFavorites] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public getPopularTables(orgId: string, pageIndex?: number, userId?: string, includeFavorites?: boolean, options?: AxiosRequestConfig) {
        return GeneralApiFp(this.configuration).getPopularTables(orgId, pageIndex, userId, includeFavorites, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Support Token
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public getSupportToken(orgId: string, options?: AxiosRequestConfig) {
        return GeneralApiFp(this.configuration).getSupportToken(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tags
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public getTags(orgId: string, options?: AxiosRequestConfig) {
        return GeneralApiFp(this.configuration).getTags(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Users To Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {AddUserToGroupRequest} addUserToGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToGroup: async (groupId: string, orgId: string, addUserToGroupRequest: AddUserToGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addUsersToGroup', 'groupId', groupId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addUsersToGroup', 'orgId', orgId)
            // verify required parameter 'addUserToGroupRequest' is not null or undefined
            assertParamExists('addUsersToGroup', 'addUserToGroupRequest', addUserToGroupRequest)
            const localVarPath = `/v1/org/{org_id}/group/{group_id}/user`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserToGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupId: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteGroup', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchGroup: async (groupId: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('fetchGroup', 'groupId', groupId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('fetchGroup', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch Group Users
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchGroupUsers: async (groupId: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('fetchGroupUsers', 'groupId', groupId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('fetchGroupUsers', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/group/{group_id}/user`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Group
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listGroup', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/group`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove User From Group
         * @param {string} groupId 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromGroup: async (groupId: string, userId: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('removeUserFromGroup', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromGroup', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('removeUserFromGroup', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/group/{group_id}/user/{user_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Users To Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {AddUserToGroupRequest} addUserToGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUsersToGroup(groupId: string, orgId: string, addUserToGroupRequest: AddUserToGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToGroup(groupId, orgId, addUserToGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupId: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupId, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchGroup(groupId: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchGroup(groupId, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch Group Users
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchGroupUsers(groupId: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchGroupUsers(groupId, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Group
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroup(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroup(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove User From Group
         * @param {string} groupId 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromGroup(groupId: string, userId: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromGroup(groupId, userId, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Users To Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {AddUserToGroupRequest} addUserToGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToGroup(groupId: string, orgId: string, addUserToGroupRequest: AddUserToGroupRequest, options?: any): AxiosPromise<AuthServiceResponse> {
            return localVarFp.addUsersToGroup(groupId, orgId, addUserToGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, orgId: string, options?: any): AxiosPromise<AuthServiceResponse> {
            return localVarFp.deleteGroup(groupId, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch Group
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchGroup(groupId: string, orgId: string, options?: any): AxiosPromise<AuthServiceResponse> {
            return localVarFp.fetchGroup(groupId, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch Group Users
         * @param {string} groupId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchGroupUsers(groupId: string, orgId: string, options?: any): AxiosPromise<AuthServiceResponse> {
            return localVarFp.fetchGroupUsers(groupId, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Group
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup(orgId: string, options?: any): AxiosPromise<AuthServiceResponse> {
            return localVarFp.listGroup(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove User From Group
         * @param {string} groupId 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromGroup(groupId: string, userId: string, orgId: string, options?: any): AxiosPromise<AuthServiceResponse> {
            return localVarFp.removeUserFromGroup(groupId, userId, orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - interface
 * @export
 * @interface GroupApi
 */
export interface GroupApiInterface {
    /**
     * 
     * @summary Add Users To Group
     * @param {string} groupId 
     * @param {string} orgId 
     * @param {AddUserToGroupRequest} addUserToGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    addUsersToGroup(groupId: string, orgId: string, addUserToGroupRequest: AddUserToGroupRequest, options?: AxiosRequestConfig): AxiosPromise<AuthServiceResponse>;

    /**
     * 
     * @summary Delete Group
     * @param {string} groupId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteGroup(groupId: string, orgId: string, options?: AxiosRequestConfig): AxiosPromise<AuthServiceResponse>;

    /**
     * 
     * @summary Fetch Group
     * @param {string} groupId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    fetchGroup(groupId: string, orgId: string, options?: AxiosRequestConfig): AxiosPromise<AuthServiceResponse>;

    /**
     * 
     * @summary Fetch Group Users
     * @param {string} groupId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    fetchGroupUsers(groupId: string, orgId: string, options?: AxiosRequestConfig): AxiosPromise<AuthServiceResponse>;

    /**
     * 
     * @summary List Group
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    listGroup(orgId: string, options?: AxiosRequestConfig): AxiosPromise<AuthServiceResponse>;

    /**
     * 
     * @summary Remove User From Group
     * @param {string} groupId 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    removeUserFromGroup(groupId: string, userId: string, orgId: string, options?: AxiosRequestConfig): AxiosPromise<AuthServiceResponse>;

}

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI implements GroupApiInterface {
    /**
     * 
     * @summary Add Users To Group
     * @param {string} groupId 
     * @param {string} orgId 
     * @param {AddUserToGroupRequest} addUserToGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addUsersToGroup(groupId: string, orgId: string, addUserToGroupRequest: AddUserToGroupRequest, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).addUsersToGroup(groupId, orgId, addUserToGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Group
     * @param {string} groupId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(groupId: string, orgId: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteGroup(groupId, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch Group
     * @param {string} groupId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public fetchGroup(groupId: string, orgId: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).fetchGroup(groupId, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch Group Users
     * @param {string} groupId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public fetchGroupUsers(groupId: string, orgId: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).fetchGroupUsers(groupId, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Group
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listGroup(orgId: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).listGroup(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove User From Group
     * @param {string} groupId 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public removeUserFromGroup(groupId: string, userId: string, orgId: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).removeUserFromGroup(groupId, userId, orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Table Metadata
         * @param {string} orgId 
         * @param {ListTableMetadataCreateSchema} listTableMetadataCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTableMetadata: async (orgId: string, listTableMetadataCreateSchema: ListTableMetadataCreateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createTableMetadata', 'orgId', orgId)
            // verify required parameter 'listTableMetadataCreateSchema' is not null or undefined
            assertParamExists('createTableMetadata', 'listTableMetadataCreateSchema', listTableMetadataCreateSchema)
            const localVarPath = `/v1/org/{org_id}/table/metadata`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listTableMetadataCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List All Table Metadata Schema
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTableMetadataSchema: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAllTableMetadataSchema', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/table/metadata`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Table Metadata
         * @param {string} orgId 
         * @param {ListTableMetadataCreateSchema} listTableMetadataCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTableMetadata(orgId: string, listTableMetadataCreateSchema: ListTableMetadataCreateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTableMetadataResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTableMetadata(orgId, listTableMetadataCreateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List All Table Metadata Schema
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTableMetadataSchema(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTableMetadataResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTableMetadataSchema(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Table Metadata
         * @param {string} orgId 
         * @param {ListTableMetadataCreateSchema} listTableMetadataCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTableMetadata(orgId: string, listTableMetadataCreateSchema: ListTableMetadataCreateSchema, options?: any): AxiosPromise<ListTableMetadataResponseSchema> {
            return localVarFp.createTableMetadata(orgId, listTableMetadataCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List All Table Metadata Schema
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTableMetadataSchema(orgId: string, options?: any): AxiosPromise<ListTableMetadataResponseSchema> {
            return localVarFp.listAllTableMetadataSchema(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - interface
 * @export
 * @interface MetadataApi
 */
export interface MetadataApiInterface {
    /**
     * 
     * @summary Create Table Metadata
     * @param {string} orgId 
     * @param {ListTableMetadataCreateSchema} listTableMetadataCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApiInterface
     */
    createTableMetadata(orgId: string, listTableMetadataCreateSchema: ListTableMetadataCreateSchema, options?: AxiosRequestConfig): AxiosPromise<ListTableMetadataResponseSchema>;

    /**
     * 
     * @summary List All Table Metadata Schema
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApiInterface
     */
    listAllTableMetadataSchema(orgId: string, options?: AxiosRequestConfig): AxiosPromise<ListTableMetadataResponseSchema>;

}

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI implements MetadataApiInterface {
    /**
     * 
     * @summary Create Table Metadata
     * @param {string} orgId 
     * @param {ListTableMetadataCreateSchema} listTableMetadataCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public createTableMetadata(orgId: string, listTableMetadataCreateSchema: ListTableMetadataCreateSchema, options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).createTableMetadata(orgId, listTableMetadataCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List All Table Metadata Schema
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public listAllTableMetadataSchema(orgId: string, options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).listAllTableMetadataSchema(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RequestApi - axios parameter creator
 * @export
 */
export const RequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Request
         * @param {string} requestId 
         * @param {string} orgId 
         * @param {'Table'} resourceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequest: async (requestId: string, orgId: string, resourceType: 'Table', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('getRequest', 'requestId', requestId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getRequest', 'orgId', orgId)
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('getRequest', 'resourceType', resourceType)
            const localVarPath = `/v1/org/{org_id}/request/{request_id}`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Table Access Request
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableAccessRequest: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getTableAccessRequest', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getTableAccessRequest', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getTableAccessRequest', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getTableAccessRequest', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('getTableAccessRequest', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/request/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Action
         * @param {string} orgId 
         * @param {string} requestId 
         * @param {Actions} action 
         * @param {'Table'} resourceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAction: async (orgId: string, requestId: string, action: Actions, resourceType: 'Table', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('requestAction', 'orgId', orgId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('requestAction', 'requestId', requestId)
            // verify required parameter 'action' is not null or undefined
            assertParamExists('requestAction', 'action', action)
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('requestAction', 'resourceType', resourceType)
            const localVarPath = `/v1/org/{org_id}/request`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['request_id'] = requestId;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Table Access
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTableAccess: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('requestTableAccess', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('requestTableAccess', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('requestTableAccess', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('requestTableAccess', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('requestTableAccess', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/request/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestApi - functional programming interface
 * @export
 */
export const RequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Request
         * @param {string} requestId 
         * @param {string} orgId 
         * @param {'Table'} resourceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequest(requestId: string, orgId: string, resourceType: 'Table', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetResourceRequestResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequest(requestId, orgId, resourceType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Table Access Request
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTableAccessRequest(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetResourceRequestResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTableAccessRequest(orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Action
         * @param {string} orgId 
         * @param {string} requestId 
         * @param {Actions} action 
         * @param {'Table'} resourceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestAction(orgId: string, requestId: string, action: Actions, resourceType: 'Table', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestAction(orgId, requestId, action, resourceType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Table Access
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTableAccess(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableAccessResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTableAccess(orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequestApi - factory interface
 * @export
 */
export const RequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Request
         * @param {string} requestId 
         * @param {string} orgId 
         * @param {'Table'} resourceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequest(requestId: string, orgId: string, resourceType: 'Table', options?: any): AxiosPromise<GetResourceRequestResponseSchema> {
            return localVarFp.getRequest(requestId, orgId, resourceType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Table Access Request
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableAccessRequest(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<GetResourceRequestResponseSchema> {
            return localVarFp.getTableAccessRequest(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Action
         * @param {string} orgId 
         * @param {string} requestId 
         * @param {Actions} action 
         * @param {'Table'} resourceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAction(orgId: string, requestId: string, action: Actions, resourceType: 'Table', options?: any): AxiosPromise<AccessResponseSchema> {
            return localVarFp.requestAction(orgId, requestId, action, resourceType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Table Access
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTableAccess(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<TableAccessResponseSchema> {
            return localVarFp.requestTableAccess(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RequestApi - interface
 * @export
 * @interface RequestApi
 */
export interface RequestApiInterface {
    /**
     * 
     * @summary Get Request
     * @param {string} requestId 
     * @param {string} orgId 
     * @param {'Table'} resourceType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApiInterface
     */
    getRequest(requestId: string, orgId: string, resourceType: 'Table', options?: AxiosRequestConfig): AxiosPromise<GetResourceRequestResponseSchema>;

    /**
     * 
     * @summary Get Table Access Request
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApiInterface
     */
    getTableAccessRequest(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<GetResourceRequestResponseSchema>;

    /**
     * 
     * @summary Request Action
     * @param {string} orgId 
     * @param {string} requestId 
     * @param {Actions} action 
     * @param {'Table'} resourceType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApiInterface
     */
    requestAction(orgId: string, requestId: string, action: Actions, resourceType: 'Table', options?: AxiosRequestConfig): AxiosPromise<AccessResponseSchema>;

    /**
     * 
     * @summary Request Table Access
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApiInterface
     */
    requestTableAccess(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<TableAccessResponseSchema>;

}

/**
 * RequestApi - object-oriented interface
 * @export
 * @class RequestApi
 * @extends {BaseAPI}
 */
export class RequestApi extends BaseAPI implements RequestApiInterface {
    /**
     * 
     * @summary Get Request
     * @param {string} requestId 
     * @param {string} orgId 
     * @param {'Table'} resourceType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public getRequest(requestId: string, orgId: string, resourceType: 'Table', options?: AxiosRequestConfig) {
        return RequestApiFp(this.configuration).getRequest(requestId, orgId, resourceType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Table Access Request
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public getTableAccessRequest(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return RequestApiFp(this.configuration).getTableAccessRequest(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Action
     * @param {string} orgId 
     * @param {string} requestId 
     * @param {Actions} action 
     * @param {'Table'} resourceType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public requestAction(orgId: string, requestId: string, action: Actions, resourceType: 'Table', options?: AxiosRequestConfig) {
        return RequestApiFp(this.configuration).requestAction(orgId, requestId, action, resourceType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Table Access
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public requestTableAccess(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return RequestApiFp(this.configuration).requestTableAccess(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Role
         * @param {string} orgId 
         * @param {CreateRoleRequestSchema} createRoleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (orgId: string, createRoleRequestSchema: CreateRoleRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createRole', 'orgId', orgId)
            // verify required parameter 'createRoleRequestSchema' is not null or undefined
            assertParamExists('createRole', 'createRoleRequestSchema', createRoleRequestSchema)
            const localVarPath = `/v1/org/{org_id}/role`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Org Roles
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgRoles: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listOrgRoles', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/role`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Role Users
         * @param {string} orgId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleUsers: async (orgId: string, roleName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listRoleUsers', 'orgId', orgId)
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('listRoleUsers', 'roleName', roleName)
            const localVarPath = `/v1/org/{org_id}/role/{role_name}/user`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"role_name"}}`, encodeURIComponent(String(roleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Role
         * @param {string} orgId 
         * @param {CreateRoleRequestSchema} createRoleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(orgId: string, createRoleRequestSchema: CreateRoleRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRoleResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(orgId, createRoleRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Org Roles
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgRoles(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrgRoleResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgRoles(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Role Users
         * @param {string} orgId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleUsers(orgId: string, roleName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleUsers(orgId, roleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Role
         * @param {string} orgId 
         * @param {CreateRoleRequestSchema} createRoleRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(orgId: string, createRoleRequestSchema: CreateRoleRequestSchema, options?: any): AxiosPromise<CreateRoleResponseSchema> {
            return localVarFp.createRole(orgId, createRoleRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Org Roles
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgRoles(orgId: string, options?: any): AxiosPromise<ListOrgRoleResponseSchema> {
            return localVarFp.listOrgRoles(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Role Users
         * @param {string} orgId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleUsers(orgId: string, roleName: string, options?: any): AxiosPromise<ListUsersResponse> {
            return localVarFp.listRoleUsers(orgId, roleName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleApi - interface
 * @export
 * @interface RoleApi
 */
export interface RoleApiInterface {
    /**
     * 
     * @summary Create Role
     * @param {string} orgId 
     * @param {CreateRoleRequestSchema} createRoleRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    createRole(orgId: string, createRoleRequestSchema: CreateRoleRequestSchema, options?: AxiosRequestConfig): AxiosPromise<CreateRoleResponseSchema>;

    /**
     * 
     * @summary List Org Roles
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    listOrgRoles(orgId: string, options?: AxiosRequestConfig): AxiosPromise<ListOrgRoleResponseSchema>;

    /**
     * 
     * @summary List Role Users
     * @param {string} orgId 
     * @param {string} roleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    listRoleUsers(orgId: string, roleName: string, options?: AxiosRequestConfig): AxiosPromise<ListUsersResponse>;

}

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI implements RoleApiInterface {
    /**
     * 
     * @summary Create Role
     * @param {string} orgId 
     * @param {CreateRoleRequestSchema} createRoleRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public createRole(orgId: string, createRoleRequestSchema: CreateRoleRequestSchema, options?: AxiosRequestConfig) {
        return RoleApiFp(this.configuration).createRole(orgId, createRoleRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Org Roles
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public listOrgRoles(orgId: string, options?: AxiosRequestConfig) {
        return RoleApiFp(this.configuration).listOrgRoles(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Role Users
     * @param {string} orgId 
     * @param {string} roleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public listRoleUsers(orgId: string, roleName: string, options?: AxiosRequestConfig) {
        return RoleApiFp(this.configuration).listRoleUsers(orgId, roleName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Schema
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (orgId: string, domainName: string, cluster: string, schemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getSchema', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getSchema', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getSchema', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getSchema', 'schemaName', schemaName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List All Schemas
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllSchemas: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAllSchemas', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/schema`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Schema Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {SchemaVisibilityUpdateRequestSchema} schemaVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaVisibility: async (orgId: string, domainName: string, cluster: string, schemaName: string, schemaVisibilityUpdateRequestSchema: SchemaVisibilityUpdateRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('setSchemaVisibility', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('setSchemaVisibility', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('setSchemaVisibility', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('setSchemaVisibility', 'schemaName', schemaName)
            // verify required parameter 'schemaVisibilityUpdateRequestSchema' is not null or undefined
            assertParamExists('setSchemaVisibility', 'schemaVisibilityUpdateRequestSchema', schemaVisibilityUpdateRequestSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/visibility`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaVisibilityUpdateRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Schema
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(orgId, domainName, cluster, schemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List All Schemas
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllSchemas(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSchemasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllSchemas(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Schema Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {SchemaVisibilityUpdateRequestSchema} schemaVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSchemaVisibility(orgId: string, domainName: string, cluster: string, schemaName: string, schemaVisibilityUpdateRequestSchema: SchemaVisibilityUpdateRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSchemaVisibility(orgId, domainName, cluster, schemaName, schemaVisibilityUpdateRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Schema
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(orgId: string, domainName: string, cluster: string, schemaName: string, options?: any): AxiosPromise<SchemaResponse> {
            return localVarFp.getSchema(orgId, domainName, cluster, schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List All Schemas
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllSchemas(orgId: string, options?: any): AxiosPromise<ListSchemasResponse> {
            return localVarFp.listAllSchemas(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Schema Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {SchemaVisibilityUpdateRequestSchema} schemaVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaVisibility(orgId: string, domainName: string, cluster: string, schemaName: string, schemaVisibilityUpdateRequestSchema: SchemaVisibilityUpdateRequestSchema, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.setSchemaVisibility(orgId, domainName, cluster, schemaName, schemaVisibilityUpdateRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - interface
 * @export
 * @interface SchemaApi
 */
export interface SchemaApiInterface {
    /**
     * 
     * @summary Get Schema
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApiInterface
     */
    getSchema(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig): AxiosPromise<SchemaResponse>;

    /**
     * 
     * @summary List All Schemas
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApiInterface
     */
    listAllSchemas(orgId: string, options?: AxiosRequestConfig): AxiosPromise<ListSchemasResponse>;

    /**
     * 
     * @summary Set Schema Visibility
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {SchemaVisibilityUpdateRequestSchema} schemaVisibilityUpdateRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApiInterface
     */
    setSchemaVisibility(orgId: string, domainName: string, cluster: string, schemaName: string, schemaVisibilityUpdateRequestSchema: SchemaVisibilityUpdateRequestSchema, options?: AxiosRequestConfig): AxiosPromise<GenericResponse>;

}

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI implements SchemaApiInterface {
    /**
     * 
     * @summary Get Schema
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public getSchema(orgId: string, domainName: string, cluster: string, schemaName: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).getSchema(orgId, domainName, cluster, schemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List All Schemas
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public listAllSchemas(orgId: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).listAllSchemas(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Schema Visibility
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {SchemaVisibilityUpdateRequestSchema} schemaVisibilityUpdateRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public setSchemaVisibility(orgId: string, domainName: string, cluster: string, schemaName: string, schemaVisibilityUpdateRequestSchema: SchemaVisibilityUpdateRequestSchema, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).setSchemaVisibility(orgId, domainName, cluster, schemaName, schemaVisibilityUpdateRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search Table
         * @param {string} orgId 
         * @param {string} [queryTerm] 
         * @param {number} [pageIndex] 
         * @param {string} [filters] E.g. tags&#x3D;tag1,tag2&amp;domain&#x3D;domainName
         * @param {string} [fields] 
         * @param {string} [highlight] 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTable: async (orgId: string, queryTerm?: string, pageIndex?: number, filters?: string, fields?: string, highlight?: string, includeFavorites?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('searchTable', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/search/table`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (queryTerm !== undefined) {
                localVarQueryParameter['query_term'] = queryTerm;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (highlight !== undefined) {
                localVarQueryParameter['highlight'] = highlight;
            }

            if (includeFavorites !== undefined) {
                localVarQueryParameter['include_favorites'] = includeFavorites;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET API for searching a user
         * @summary Search User
         * @param {string} orgId 
         * @param {string} [queryTerm] 
         * @param {number} [pageIndex] 
         * @param {string} [highlight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUser: async (orgId: string, queryTerm?: string, pageIndex?: number, highlight?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('searchUser', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/search/user`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (queryTerm !== undefined) {
                localVarQueryParameter['query_term'] = queryTerm;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }

            if (highlight !== undefined) {
                localVarQueryParameter['highlight'] = highlight;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search Table
         * @param {string} orgId 
         * @param {string} [queryTerm] 
         * @param {number} [pageIndex] 
         * @param {string} [filters] E.g. tags&#x3D;tag1,tag2&amp;domain&#x3D;domainName
         * @param {string} [fields] 
         * @param {string} [highlight] 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTable(orgId: string, queryTerm?: string, pageIndex?: number, filters?: string, fields?: string, highlight?: string, includeFavorites?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTable(orgId, queryTerm, pageIndex, filters, fields, highlight, includeFavorites, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * GET API for searching a user
         * @summary Search User
         * @param {string} orgId 
         * @param {string} [queryTerm] 
         * @param {number} [pageIndex] 
         * @param {string} [highlight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUser(orgId: string, queryTerm?: string, pageIndex?: number, highlight?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUser(orgId, queryTerm, pageIndex, highlight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @summary Search Table
         * @param {string} orgId 
         * @param {string} [queryTerm] 
         * @param {number} [pageIndex] 
         * @param {string} [filters] E.g. tags&#x3D;tag1,tag2&amp;domain&#x3D;domainName
         * @param {string} [fields] 
         * @param {string} [highlight] 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTable(orgId: string, queryTerm?: string, pageIndex?: number, filters?: string, fields?: string, highlight?: string, includeFavorites?: boolean, options?: any): AxiosPromise<SearchTableResponse> {
            return localVarFp.searchTable(orgId, queryTerm, pageIndex, filters, fields, highlight, includeFavorites, options).then((request) => request(axios, basePath));
        },
        /**
         * GET API for searching a user
         * @summary Search User
         * @param {string} orgId 
         * @param {string} [queryTerm] 
         * @param {number} [pageIndex] 
         * @param {string} [highlight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUser(orgId: string, queryTerm?: string, pageIndex?: number, highlight?: string, options?: any): AxiosPromise<SearchUserResponse> {
            return localVarFp.searchUser(orgId, queryTerm, pageIndex, highlight, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - interface
 * @export
 * @interface SearchApi
 */
export interface SearchApiInterface {
    /**
     * 
     * @summary Search Table
     * @param {string} orgId 
     * @param {string} [queryTerm] 
     * @param {number} [pageIndex] 
     * @param {string} [filters] E.g. tags&#x3D;tag1,tag2&amp;domain&#x3D;domainName
     * @param {string} [fields] 
     * @param {string} [highlight] 
     * @param {boolean} [includeFavorites] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApiInterface
     */
    searchTable(orgId: string, queryTerm?: string, pageIndex?: number, filters?: string, fields?: string, highlight?: string, includeFavorites?: boolean, options?: AxiosRequestConfig): AxiosPromise<SearchTableResponse>;

    /**
     * GET API for searching a user
     * @summary Search User
     * @param {string} orgId 
     * @param {string} [queryTerm] 
     * @param {number} [pageIndex] 
     * @param {string} [highlight] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApiInterface
     */
    searchUser(orgId: string, queryTerm?: string, pageIndex?: number, highlight?: string, options?: AxiosRequestConfig): AxiosPromise<SearchUserResponse>;

}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI implements SearchApiInterface {
    /**
     * 
     * @summary Search Table
     * @param {string} orgId 
     * @param {string} [queryTerm] 
     * @param {number} [pageIndex] 
     * @param {string} [filters] E.g. tags&#x3D;tag1,tag2&amp;domain&#x3D;domainName
     * @param {string} [fields] 
     * @param {string} [highlight] 
     * @param {boolean} [includeFavorites] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchTable(orgId: string, queryTerm?: string, pageIndex?: number, filters?: string, fields?: string, highlight?: string, includeFavorites?: boolean, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchTable(orgId, queryTerm, pageIndex, filters, fields, highlight, includeFavorites, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET API for searching a user
     * @summary Search User
     * @param {string} orgId 
     * @param {string} [queryTerm] 
     * @param {number} [pageIndex] 
     * @param {string} [highlight] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUser(orgId: string, queryTerm?: string, pageIndex?: number, highlight?: string, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUser(orgId, queryTerm, pageIndex, highlight, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TableApi - axios parameter creator
 * @export
 */
export const TableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Table Classification
         * @param {string} classificationTag 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTableClassification: async (classificationTag: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classificationTag' is not null or undefined
            assertParamExists('addTableClassification', 'classificationTag', classificationTag)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addTableClassification', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('addTableClassification', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('addTableClassification', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('addTableClassification', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('addTableClassification', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/classification/{classification_tag}`
                .replace(`{${"classification_tag"}}`, encodeURIComponent(String(classificationTag)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Table Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTableOwner: async (owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('addTableOwner', 'owner', owner)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addTableOwner', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('addTableOwner', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('addTableOwner', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('addTableOwner', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('addTableOwner', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/owner/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Table Column Classification
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTableColumnClassification: async (columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnName' is not null or undefined
            assertParamExists('deleteTableColumnClassification', 'columnName', columnName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteTableColumnClassification', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('deleteTableColumnClassification', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('deleteTableColumnClassification', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('deleteTableColumnClassification', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('deleteTableColumnClassification', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/column/{column_name}/classification`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Table Column Description
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTableColumnDescription: async (columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnName' is not null or undefined
            assertParamExists('deleteTableColumnDescription', 'columnName', columnName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteTableColumnDescription', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('deleteTableColumnDescription', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('deleteTableColumnDescription', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('deleteTableColumnDescription', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('deleteTableColumnDescription', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/column/{column_name}/description`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Table Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTableOwner: async (owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('deleteTableOwner', 'owner', owner)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteTableOwner', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('deleteTableOwner', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('deleteTableOwner', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('deleteTableOwner', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('deleteTableOwner', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/owner/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Table Tag
         * @param {string} tagId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTableTag: async (tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTableTag', 'tagId', tagId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteTableTag', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('deleteTableTag', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('deleteTableTag', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('deleteTableTag', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('deleteTableTag', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/tag/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Table
         * @param {string} tableName 
         * @param {string} schemaName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} authUser 
         * @param {string} signature 
         * @param {number} validUntil 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTable: async (tableName: string, schemaName: string, orgId: string, domainName: string, cluster: string, authUser: string, signature: string, validUntil: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('downloadTable', 'tableName', tableName)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('downloadTable', 'schemaName', schemaName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('downloadTable', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('downloadTable', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('downloadTable', 'cluster', cluster)
            // verify required parameter 'authUser' is not null or undefined
            assertParamExists('downloadTable', 'authUser', authUser)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('downloadTable', 'signature', signature)
            // verify required parameter 'validUntil' is not null or undefined
            assertParamExists('downloadTable', 'validUntil', validUntil)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/download/verified`
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authUser !== undefined) {
                localVarQueryParameter['auth_user'] = authUser;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            if (validUntil !== undefined) {
                localVarQueryParameter['valid_until'] = validUntil;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Table As Csv
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTableAsCsv: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('downloadTableAsCsv', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('downloadTableAsCsv', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('downloadTableAsCsv', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('downloadTableAsCsv', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('downloadTableAsCsv', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/download`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch Table Preview Data
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTablePreviewData: async (domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('fetchTablePreviewData', 'domainName', domainName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('fetchTablePreviewData', 'orgId', orgId)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('fetchTablePreviewData', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('fetchTablePreviewData', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('fetchTablePreviewData', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/snapshot`
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Follow Count
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowCount: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getFollowCount', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getFollowCount', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getFollowCount', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getFollowCount', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('getFollowCount', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/follow/count`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Table
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {boolean} [includeFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTable: async (domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, includeFavorite?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getTable', 'domainName', domainName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getTable', 'orgId', orgId)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getTable', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getTable', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('getTable', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}`
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (includeFavorite !== undefined) {
                localVarQueryParameter['include_favorite'] = includeFavorite;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Table Access Status
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableAccessStatus: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getTableAccessStatus', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getTableAccessStatus', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getTableAccessStatus', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getTableAccessStatus', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('getTableAccessStatus', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/access/status`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Table Description
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableDescription: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getTableDescription', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getTableDescription', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getTableDescription', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getTableDescription', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('getTableDescription', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/description`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Table Lineage
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableLineage: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getTableLineage', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getTableLineage', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getTableLineage', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getTableLineage', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('getTableLineage', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/lineage`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grant User Table Access
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantUserTableAccess: async (userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('grantUserTableAccess', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('grantUserTableAccess', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('grantUserTableAccess', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('grantUserTableAccess', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('grantUserTableAccess', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('grantUserTableAccess', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/user/{user_id}/access`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Table Access Requests
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTableAccessRequests: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listTableAccessRequests', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('listTableAccessRequests', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('listTableAccessRequests', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('listTableAccessRequests', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('listTableAccessRequests', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/request`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Tables In Schema
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {boolean} [includeUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTablesInSchema: async (orgId: string, domainName: string, cluster: string, schemaName: string, includeUserCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listTablesInSchema', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('listTablesInSchema', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('listTablesInSchema', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('listTablesInSchema', 'schemaName', schemaName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (includeUserCount !== undefined) {
                localVarQueryParameter['include_user_count'] = includeUserCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users Have Table Access
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersHaveTableAccess: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listUsersHaveTableAccess', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('listUsersHaveTableAccess', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('listUsersHaveTableAccess', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('listUsersHaveTableAccess', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('listUsersHaveTableAccess', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/access`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke User Table Access
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserTableAccess: async (userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('revokeUserTableAccess', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('revokeUserTableAccess', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('revokeUserTableAccess', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('revokeUserTableAccess', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('revokeUserTableAccess', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('revokeUserTableAccess', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/user/{user_id}/access`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Table Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableVisibilityUpdateRequestSchema} tableVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTableVisibility: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableVisibilityUpdateRequestSchema: TableVisibilityUpdateRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('setTableVisibility', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('setTableVisibility', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('setTableVisibility', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('setTableVisibility', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('setTableVisibility', 'tableName', tableName)
            // verify required parameter 'tableVisibilityUpdateRequestSchema' is not null or undefined
            assertParamExists('setTableVisibility', 'tableVisibilityUpdateRequestSchema', tableVisibilityUpdateRequestSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/visibility`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tableVisibilityUpdateRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Table
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableUpdateSchema} tableUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTable: async (domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, tableUpdateSchema: TableUpdateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('updateTable', 'domainName', domainName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateTable', 'orgId', orgId)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('updateTable', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('updateTable', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('updateTable', 'tableName', tableName)
            // verify required parameter 'tableUpdateSchema' is not null or undefined
            assertParamExists('updateTable', 'tableUpdateSchema', tableUpdateSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}`
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tableUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Table Column
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnUpdateSchema} tableColumnUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableColumn: async (columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnUpdateSchema: TableColumnUpdateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnName' is not null or undefined
            assertParamExists('updateTableColumn', 'columnName', columnName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateTableColumn', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('updateTableColumn', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('updateTableColumn', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('updateTableColumn', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('updateTableColumn', 'tableName', tableName)
            // verify required parameter 'tableColumnUpdateSchema' is not null or undefined
            assertParamExists('updateTableColumn', 'tableColumnUpdateSchema', tableColumnUpdateSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/column/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tableColumnUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Table Column Classification
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnClassificationUpdateSchema} tableColumnClassificationUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableColumnClassification: async (columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnClassificationUpdateSchema: TableColumnClassificationUpdateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnName' is not null or undefined
            assertParamExists('updateTableColumnClassification', 'columnName', columnName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateTableColumnClassification', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('updateTableColumnClassification', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('updateTableColumnClassification', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('updateTableColumnClassification', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('updateTableColumnClassification', 'tableName', tableName)
            // verify required parameter 'tableColumnClassificationUpdateSchema' is not null or undefined
            assertParamExists('updateTableColumnClassification', 'tableColumnClassificationUpdateSchema', tableColumnClassificationUpdateSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/column/{column_name}/classification`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tableColumnClassificationUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Table Column Description
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnDescUpdateSchema} tableColumnDescUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableColumnDescription: async (columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnDescUpdateSchema: TableColumnDescUpdateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnName' is not null or undefined
            assertParamExists('updateTableColumnDescription', 'columnName', columnName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateTableColumnDescription', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('updateTableColumnDescription', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('updateTableColumnDescription', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('updateTableColumnDescription', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('updateTableColumnDescription', 'tableName', tableName)
            // verify required parameter 'tableColumnDescUpdateSchema' is not null or undefined
            assertParamExists('updateTableColumnDescription', 'tableColumnDescUpdateSchema', tableColumnDescUpdateSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/column/{column_name}/description`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tableColumnDescUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Table Column Meta
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnMetaUpdateSchema} tableColumnMetaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableColumnMeta: async (columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnMetaUpdateSchema: TableColumnMetaUpdateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnName' is not null or undefined
            assertParamExists('updateTableColumnMeta', 'columnName', columnName)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateTableColumnMeta', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('updateTableColumnMeta', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('updateTableColumnMeta', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('updateTableColumnMeta', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('updateTableColumnMeta', 'tableName', tableName)
            // verify required parameter 'tableColumnMetaUpdateSchema' is not null or undefined
            assertParamExists('updateTableColumnMeta', 'tableColumnMetaUpdateSchema', tableColumnMetaUpdateSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/column/{column_name}/meta`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tableColumnMetaUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Table Description
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableDescriptionUpdateSchema} tableDescriptionUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableDescription: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableDescriptionUpdateSchema: TableDescriptionUpdateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateTableDescription', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('updateTableDescription', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('updateTableDescription', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('updateTableDescription', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('updateTableDescription', 'tableName', tableName)
            // verify required parameter 'tableDescriptionUpdateSchema' is not null or undefined
            assertParamExists('updateTableDescription', 'tableDescriptionUpdateSchema', tableDescriptionUpdateSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/description`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tableDescriptionUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Table Meta
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableMetaUpdateSchema} tableMetaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableMeta: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableMetaUpdateSchema: TableMetaUpdateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateTableMeta', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('updateTableMeta', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('updateTableMeta', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('updateTableMeta', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('updateTableMeta', 'tableName', tableName)
            // verify required parameter 'tableMetaUpdateSchema' is not null or undefined
            assertParamExists('updateTableMeta', 'tableMetaUpdateSchema', tableMetaUpdateSchema)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/meta`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tableMetaUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Table Tag
         * @param {string} tagId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableTag: async (tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('updateTableTag', 'tagId', tagId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateTableTag', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('updateTableTag', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('updateTableTag', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('updateTableTag', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('updateTableTag', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/tag/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TableApi - functional programming interface
 * @export
 */
export const TableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TableApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Table Classification
         * @param {string} classificationTag 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTableClassification(classificationTag: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTableClassification(classificationTag, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Table Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTableOwner(owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTableOwner(owner, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Table Column Classification
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTableColumnClassification(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTableColumnClassification(columnName, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Table Column Description
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTableColumnDescription(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetResourceDescriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTableColumnDescription(columnName, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Table Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTableOwner(owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTableOwner(owner, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Table Tag
         * @param {string} tagId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTableTag(tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateResourceTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTableTag(tagId, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download Table
         * @param {string} tableName 
         * @param {string} schemaName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} authUser 
         * @param {string} signature 
         * @param {number} validUntil 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTable(tableName: string, schemaName: string, orgId: string, domainName: string, cluster: string, authUser: string, signature: string, validUntil: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTable(tableName, schemaName, orgId, domainName, cluster, authUser, signature, validUntil, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download Table As Csv
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTableAsCsv(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTableAsCsv(orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch Table Preview Data
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTablePreviewData(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchTablePreviewData(domainName, orgId, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Follow Count
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowCount(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFollowCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowCount(orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Table
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {boolean} [includeFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTable(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, includeFavorite?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTable(domainName, orgId, cluster, schemaName, tableName, includeFavorite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Table Access Status
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTableAccessStatus(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersTableHaveAccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTableAccessStatus(orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Table Description
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTableDescription(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetResourceDescriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTableDescription(orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Table Lineage
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTableLineage(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableLineageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTableLineage(orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Grant User Table Access
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grantUserTableAccess(userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.grantUserTableAccess(userId, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Table Access Requests
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTableAccessRequests(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTableRequestsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTableAccessRequests(orgId, domainName, cluster, schemaName, tableName, pageIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Tables In Schema
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {boolean} [includeUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTablesInSchema(orgId: string, domainName: string, cluster: string, schemaName: string, includeUserCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaTableListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTablesInSchema(orgId, domainName, cluster, schemaName, includeUserCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users Have Table Access
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersHaveTableAccess(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersTableHaveAccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersHaveTableAccess(orgId, domainName, cluster, schemaName, tableName, pageIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke User Table Access
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeUserTableAccess(userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeUserTableAccess(userId, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Table Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableVisibilityUpdateRequestSchema} tableVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTableVisibility(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableVisibilityUpdateRequestSchema: TableVisibilityUpdateRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTableVisibility(orgId, domainName, cluster, schemaName, tableName, tableVisibilityUpdateRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Table
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableUpdateSchema} tableUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTable(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, tableUpdateSchema: TableUpdateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTable(domainName, orgId, cluster, schemaName, tableName, tableUpdateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Table Column
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnUpdateSchema} tableColumnUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTableColumn(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnUpdateSchema: TableColumnUpdateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTableColumn(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnUpdateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Table Column Classification
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnClassificationUpdateSchema} tableColumnClassificationUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTableColumnClassification(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnClassificationUpdateSchema: TableColumnClassificationUpdateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTableColumnClassification(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnClassificationUpdateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Table Column Description
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnDescUpdateSchema} tableColumnDescUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTableColumnDescription(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnDescUpdateSchema: TableColumnDescUpdateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateResourceDescriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTableColumnDescription(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnDescUpdateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Table Column Meta
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnMetaUpdateSchema} tableColumnMetaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTableColumnMeta(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnMetaUpdateSchema: TableColumnMetaUpdateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTableColumnMeta(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnMetaUpdateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Table Description
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableDescriptionUpdateSchema} tableDescriptionUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTableDescription(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableDescriptionUpdateSchema: TableDescriptionUpdateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateResourceDescriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTableDescription(orgId, domainName, cluster, schemaName, tableName, tableDescriptionUpdateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Table Meta
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableMetaUpdateSchema} tableMetaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTableMeta(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableMetaUpdateSchema: TableMetaUpdateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTableMeta(orgId, domainName, cluster, schemaName, tableName, tableMetaUpdateSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Table Tag
         * @param {string} tagId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTableTag(tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateResourceTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTableTag(tagId, orgId, domainName, cluster, schemaName, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TableApi - factory interface
 * @export
 */
export const TableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TableApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Table Classification
         * @param {string} classificationTag 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTableClassification(classificationTag: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.addTableClassification(classificationTag, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Table Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTableOwner(owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<any> {
            return localVarFp.addTableOwner(owner, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Table Column Classification
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTableColumnClassification(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<TableLong> {
            return localVarFp.deleteTableColumnClassification(columnName, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Table Column Description
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTableColumnDescription(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<GetResourceDescriptionResponse> {
            return localVarFp.deleteTableColumnDescription(columnName, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Table Owner
         * @param {string} owner 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTableOwner(owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteTableOwner(owner, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Table Tag
         * @param {string} tagId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTableTag(tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<UpdateResourceTagResponse> {
            return localVarFp.deleteTableTag(tagId, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Table
         * @param {string} tableName 
         * @param {string} schemaName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} authUser 
         * @param {string} signature 
         * @param {number} validUntil 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTable(tableName: string, schemaName: string, orgId: string, domainName: string, cluster: string, authUser: string, signature: string, validUntil: number, options?: any): AxiosPromise<any> {
            return localVarFp.downloadTable(tableName, schemaName, orgId, domainName, cluster, authUser, signature, validUntil, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Table As Csv
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTableAsCsv(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadTableAsCsv(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch Table Preview Data
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTablePreviewData(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<any> {
            return localVarFp.fetchTablePreviewData(domainName, orgId, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Follow Count
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowCount(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<GetFollowCountResponse> {
            return localVarFp.getFollowCount(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Table
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {boolean} [includeFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTable(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, includeFavorite?: boolean, options?: any): AxiosPromise<TableLong> {
            return localVarFp.getTable(domainName, orgId, cluster, schemaName, tableName, includeFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Table Access Status
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableAccessStatus(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<ListUsersTableHaveAccessResponse> {
            return localVarFp.getTableAccessStatus(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Table Description
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableDescription(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<GetResourceDescriptionResponse> {
            return localVarFp.getTableDescription(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Table Lineage
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableLineage(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<TableLineageResponse> {
            return localVarFp.getTableLineage(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Grant User Table Access
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantUserTableAccess(userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.grantUserTableAccess(userId, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Table Access Requests
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTableAccessRequests(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options?: any): AxiosPromise<ListTableRequestsResponse> {
            return localVarFp.listTableAccessRequests(orgId, domainName, cluster, schemaName, tableName, pageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Tables In Schema
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {boolean} [includeUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTablesInSchema(orgId: string, domainName: string, cluster: string, schemaName: string, includeUserCount?: boolean, options?: any): AxiosPromise<SchemaTableListResponse> {
            return localVarFp.listTablesInSchema(orgId, domainName, cluster, schemaName, includeUserCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users Have Table Access
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersHaveTableAccess(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options?: any): AxiosPromise<ListUsersTableHaveAccessResponse> {
            return localVarFp.listUsersHaveTableAccess(orgId, domainName, cluster, schemaName, tableName, pageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke User Table Access
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserTableAccess(userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.revokeUserTableAccess(userId, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Table Visibility
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableVisibilityUpdateRequestSchema} tableVisibilityUpdateRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTableVisibility(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableVisibilityUpdateRequestSchema: TableVisibilityUpdateRequestSchema, options?: any): AxiosPromise<any> {
            return localVarFp.setTableVisibility(orgId, domainName, cluster, schemaName, tableName, tableVisibilityUpdateRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Table
         * @param {string} domainName 
         * @param {string} orgId 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableUpdateSchema} tableUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTable(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, tableUpdateSchema: TableUpdateSchema, options?: any): AxiosPromise<any> {
            return localVarFp.updateTable(domainName, orgId, cluster, schemaName, tableName, tableUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Table Column
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnUpdateSchema} tableColumnUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableColumn(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnUpdateSchema: TableColumnUpdateSchema, options?: any): AxiosPromise<any> {
            return localVarFp.updateTableColumn(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Table Column Classification
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnClassificationUpdateSchema} tableColumnClassificationUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableColumnClassification(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnClassificationUpdateSchema: TableColumnClassificationUpdateSchema, options?: any): AxiosPromise<TableLong> {
            return localVarFp.updateTableColumnClassification(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnClassificationUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Table Column Description
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnDescUpdateSchema} tableColumnDescUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableColumnDescription(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnDescUpdateSchema: TableColumnDescUpdateSchema, options?: any): AxiosPromise<UpdateResourceDescriptionResponse> {
            return localVarFp.updateTableColumnDescription(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnDescUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Table Column Meta
         * @param {string} columnName 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableColumnMetaUpdateSchema} tableColumnMetaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableColumnMeta(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnMetaUpdateSchema: TableColumnMetaUpdateSchema, options?: any): AxiosPromise<TableLong> {
            return localVarFp.updateTableColumnMeta(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnMetaUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Table Description
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableDescriptionUpdateSchema} tableDescriptionUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableDescription(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableDescriptionUpdateSchema: TableDescriptionUpdateSchema, options?: any): AxiosPromise<UpdateResourceDescriptionResponse> {
            return localVarFp.updateTableDescription(orgId, domainName, cluster, schemaName, tableName, tableDescriptionUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Table Meta
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableMetaUpdateSchema} tableMetaUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableMeta(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableMetaUpdateSchema: TableMetaUpdateSchema, options?: any): AxiosPromise<TableLong> {
            return localVarFp.updateTableMeta(orgId, domainName, cluster, schemaName, tableName, tableMetaUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Table Tag
         * @param {string} tagId 
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTableTag(tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: any): AxiosPromise<UpdateResourceTagResponse> {
            return localVarFp.updateTableTag(tagId, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TableApi - interface
 * @export
 * @interface TableApi
 */
export interface TableApiInterface {
    /**
     * 
     * @summary Add Table Classification
     * @param {string} classificationTag 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    addTableClassification(classificationTag: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<GenericResponse>;

    /**
     * 
     * @summary Add Table Owner
     * @param {string} owner 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    addTableOwner(owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Delete Table Column Classification
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    deleteTableColumnClassification(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<TableLong>;

    /**
     * 
     * @summary Delete Table Column Description
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    deleteTableColumnDescription(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<GetResourceDescriptionResponse>;

    /**
     * 
     * @summary Delete Table Owner
     * @param {string} owner 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    deleteTableOwner(owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Delete Table Tag
     * @param {string} tagId 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    deleteTableTag(tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<UpdateResourceTagResponse>;

    /**
     * 
     * @summary Download Table
     * @param {string} tableName 
     * @param {string} schemaName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} authUser 
     * @param {string} signature 
     * @param {number} validUntil 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    downloadTable(tableName: string, schemaName: string, orgId: string, domainName: string, cluster: string, authUser: string, signature: string, validUntil: number, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Download Table As Csv
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    downloadTableAsCsv(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Fetch Table Preview Data
     * @param {string} domainName 
     * @param {string} orgId 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    fetchTablePreviewData(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Follow Count
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    getFollowCount(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<GetFollowCountResponse>;

    /**
     * 
     * @summary Get Table
     * @param {string} domainName 
     * @param {string} orgId 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {boolean} [includeFavorite] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    getTable(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, includeFavorite?: boolean, options?: AxiosRequestConfig): AxiosPromise<TableLong>;

    /**
     * 
     * @summary Get Table Access Status
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    getTableAccessStatus(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<ListUsersTableHaveAccessResponse>;

    /**
     * 
     * @summary Get Table Description
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    getTableDescription(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<GetResourceDescriptionResponse>;

    /**
     * 
     * @summary Get Table Lineage
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    getTableLineage(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<TableLineageResponse>;

    /**
     * 
     * @summary Grant User Table Access
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    grantUserTableAccess(userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<GenericResponse>;

    /**
     * 
     * @summary List Table Access Requests
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {number} [pageIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    listTableAccessRequests(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options?: AxiosRequestConfig): AxiosPromise<ListTableRequestsResponse>;

    /**
     * 
     * @summary List Tables In Schema
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {boolean} [includeUserCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    listTablesInSchema(orgId: string, domainName: string, cluster: string, schemaName: string, includeUserCount?: boolean, options?: AxiosRequestConfig): AxiosPromise<SchemaTableListResponse>;

    /**
     * 
     * @summary List Users Have Table Access
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {number} [pageIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    listUsersHaveTableAccess(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options?: AxiosRequestConfig): AxiosPromise<ListUsersTableHaveAccessResponse>;

    /**
     * 
     * @summary Revoke User Table Access
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    revokeUserTableAccess(userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<GenericResponse>;

    /**
     * 
     * @summary Set Table Visibility
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableVisibilityUpdateRequestSchema} tableVisibilityUpdateRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    setTableVisibility(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableVisibilityUpdateRequestSchema: TableVisibilityUpdateRequestSchema, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Update Table
     * @param {string} domainName 
     * @param {string} orgId 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableUpdateSchema} tableUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    updateTable(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, tableUpdateSchema: TableUpdateSchema, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Update Table Column
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableColumnUpdateSchema} tableColumnUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    updateTableColumn(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnUpdateSchema: TableColumnUpdateSchema, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Update Table Column Classification
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableColumnClassificationUpdateSchema} tableColumnClassificationUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    updateTableColumnClassification(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnClassificationUpdateSchema: TableColumnClassificationUpdateSchema, options?: AxiosRequestConfig): AxiosPromise<TableLong>;

    /**
     * 
     * @summary Update Table Column Description
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableColumnDescUpdateSchema} tableColumnDescUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    updateTableColumnDescription(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnDescUpdateSchema: TableColumnDescUpdateSchema, options?: AxiosRequestConfig): AxiosPromise<UpdateResourceDescriptionResponse>;

    /**
     * 
     * @summary Update Table Column Meta
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableColumnMetaUpdateSchema} tableColumnMetaUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    updateTableColumnMeta(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnMetaUpdateSchema: TableColumnMetaUpdateSchema, options?: AxiosRequestConfig): AxiosPromise<TableLong>;

    /**
     * 
     * @summary Update Table Description
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableDescriptionUpdateSchema} tableDescriptionUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    updateTableDescription(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableDescriptionUpdateSchema: TableDescriptionUpdateSchema, options?: AxiosRequestConfig): AxiosPromise<UpdateResourceDescriptionResponse>;

    /**
     * 
     * @summary Update Table Meta
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableMetaUpdateSchema} tableMetaUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    updateTableMeta(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableMetaUpdateSchema: TableMetaUpdateSchema, options?: AxiosRequestConfig): AxiosPromise<TableLong>;

    /**
     * 
     * @summary Update Table Tag
     * @param {string} tagId 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApiInterface
     */
    updateTableTag(tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<UpdateResourceTagResponse>;

}

/**
 * TableApi - object-oriented interface
 * @export
 * @class TableApi
 * @extends {BaseAPI}
 */
export class TableApi extends BaseAPI implements TableApiInterface {
    /**
     * 
     * @summary Add Table Classification
     * @param {string} classificationTag 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public addTableClassification(classificationTag: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).addTableClassification(classificationTag, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Table Owner
     * @param {string} owner 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public addTableOwner(owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).addTableOwner(owner, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Table Column Classification
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public deleteTableColumnClassification(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).deleteTableColumnClassification(columnName, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Table Column Description
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public deleteTableColumnDescription(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).deleteTableColumnDescription(columnName, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Table Owner
     * @param {string} owner 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public deleteTableOwner(owner: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).deleteTableOwner(owner, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Table Tag
     * @param {string} tagId 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public deleteTableTag(tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).deleteTableTag(tagId, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Table
     * @param {string} tableName 
     * @param {string} schemaName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} authUser 
     * @param {string} signature 
     * @param {number} validUntil 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public downloadTable(tableName: string, schemaName: string, orgId: string, domainName: string, cluster: string, authUser: string, signature: string, validUntil: number, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).downloadTable(tableName, schemaName, orgId, domainName, cluster, authUser, signature, validUntil, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Table As Csv
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public downloadTableAsCsv(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).downloadTableAsCsv(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch Table Preview Data
     * @param {string} domainName 
     * @param {string} orgId 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public fetchTablePreviewData(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).fetchTablePreviewData(domainName, orgId, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Follow Count
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public getFollowCount(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).getFollowCount(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Table
     * @param {string} domainName 
     * @param {string} orgId 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {boolean} [includeFavorite] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public getTable(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, includeFavorite?: boolean, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).getTable(domainName, orgId, cluster, schemaName, tableName, includeFavorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Table Access Status
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public getTableAccessStatus(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).getTableAccessStatus(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Table Description
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public getTableDescription(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).getTableDescription(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Table Lineage
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public getTableLineage(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).getTableLineage(orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Grant User Table Access
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public grantUserTableAccess(userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).grantUserTableAccess(userId, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Table Access Requests
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {number} [pageIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public listTableAccessRequests(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).listTableAccessRequests(orgId, domainName, cluster, schemaName, tableName, pageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Tables In Schema
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {boolean} [includeUserCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public listTablesInSchema(orgId: string, domainName: string, cluster: string, schemaName: string, includeUserCount?: boolean, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).listTablesInSchema(orgId, domainName, cluster, schemaName, includeUserCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users Have Table Access
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {number} [pageIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public listUsersHaveTableAccess(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, pageIndex?: number, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).listUsersHaveTableAccess(orgId, domainName, cluster, schemaName, tableName, pageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke User Table Access
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public revokeUserTableAccess(userId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).revokeUserTableAccess(userId, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Table Visibility
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableVisibilityUpdateRequestSchema} tableVisibilityUpdateRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public setTableVisibility(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableVisibilityUpdateRequestSchema: TableVisibilityUpdateRequestSchema, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).setTableVisibility(orgId, domainName, cluster, schemaName, tableName, tableVisibilityUpdateRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Table
     * @param {string} domainName 
     * @param {string} orgId 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableUpdateSchema} tableUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public updateTable(domainName: string, orgId: string, cluster: string, schemaName: string, tableName: string, tableUpdateSchema: TableUpdateSchema, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).updateTable(domainName, orgId, cluster, schemaName, tableName, tableUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Table Column
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableColumnUpdateSchema} tableColumnUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public updateTableColumn(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnUpdateSchema: TableColumnUpdateSchema, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).updateTableColumn(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Table Column Classification
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableColumnClassificationUpdateSchema} tableColumnClassificationUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public updateTableColumnClassification(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnClassificationUpdateSchema: TableColumnClassificationUpdateSchema, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).updateTableColumnClassification(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnClassificationUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Table Column Description
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableColumnDescUpdateSchema} tableColumnDescUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public updateTableColumnDescription(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnDescUpdateSchema: TableColumnDescUpdateSchema, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).updateTableColumnDescription(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnDescUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Table Column Meta
     * @param {string} columnName 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableColumnMetaUpdateSchema} tableColumnMetaUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public updateTableColumnMeta(columnName: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableColumnMetaUpdateSchema: TableColumnMetaUpdateSchema, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).updateTableColumnMeta(columnName, orgId, domainName, cluster, schemaName, tableName, tableColumnMetaUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Table Description
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableDescriptionUpdateSchema} tableDescriptionUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public updateTableDescription(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableDescriptionUpdateSchema: TableDescriptionUpdateSchema, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).updateTableDescription(orgId, domainName, cluster, schemaName, tableName, tableDescriptionUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Table Meta
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableMetaUpdateSchema} tableMetaUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public updateTableMeta(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, tableMetaUpdateSchema: TableMetaUpdateSchema, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).updateTableMeta(orgId, domainName, cluster, schemaName, tableName, tableMetaUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Table Tag
     * @param {string} tagId 
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableApi
     */
    public updateTableTag(tagId: string, orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, options?: AxiosRequestConfig) {
        return TableApiFp(this.configuration).updateTableTag(tagId, orgId, domainName, cluster, schemaName, tableName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TableAccessApi - axios parameter creator
 * @export
 */
export const TableAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Notebook
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} schemaName 
         * @param {string} cluster 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebook: async (orgId: string, domainName: string, schemaName: string, cluster: string, tableName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getNotebook', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getNotebook', 'domainName', domainName)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getNotebook', 'schemaName', schemaName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getNotebook', 'cluster', cluster)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('getNotebook', 'tableName', tableName)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/notebook`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Table Visualizations
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableVisualizationType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableVisualizations: async (orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, type: TableVisualizationType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getTableVisualizations', 'orgId', orgId)
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getTableVisualizations', 'domainName', domainName)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('getTableVisualizations', 'cluster', cluster)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getTableVisualizations', 'schemaName', schemaName)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('getTableVisualizations', 'tableName', tableName)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTableVisualizations', 'type', type)
            const localVarPath = `/v1/org/{org_id}/domain/{domain_name}/cluster/{cluster}/schema/{schema_name}/table/{table_name}/visualization`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TableAccessApi - functional programming interface
 * @export
 */
export const TableAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TableAccessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Notebook
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} schemaName 
         * @param {string} cluster 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotebook(orgId: string, domainName: string, schemaName: string, cluster: string, tableName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotebook(orgId, domainName, schemaName, cluster, tableName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Table Visualizations
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableVisualizationType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTableVisualizations(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, type: TableVisualizationType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTableVisualizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTableVisualizations(orgId, domainName, cluster, schemaName, tableName, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TableAccessApi - factory interface
 * @export
 */
export const TableAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TableAccessApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Notebook
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} schemaName 
         * @param {string} cluster 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebook(orgId: string, domainName: string, schemaName: string, cluster: string, tableName: string, options?: any): AxiosPromise<any> {
            return localVarFp.getNotebook(orgId, domainName, schemaName, cluster, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Table Visualizations
         * @param {string} orgId 
         * @param {string} domainName 
         * @param {string} cluster 
         * @param {string} schemaName 
         * @param {string} tableName 
         * @param {TableVisualizationType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableVisualizations(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, type: TableVisualizationType, options?: any): AxiosPromise<GetTableVisualizationResponse> {
            return localVarFp.getTableVisualizations(orgId, domainName, cluster, schemaName, tableName, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TableAccessApi - interface
 * @export
 * @interface TableAccessApi
 */
export interface TableAccessApiInterface {
    /**
     * 
     * @summary Get Notebook
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} schemaName 
     * @param {string} cluster 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableAccessApiInterface
     */
    getNotebook(orgId: string, domainName: string, schemaName: string, cluster: string, tableName: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Table Visualizations
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableVisualizationType} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableAccessApiInterface
     */
    getTableVisualizations(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, type: TableVisualizationType, options?: AxiosRequestConfig): AxiosPromise<GetTableVisualizationResponse>;

}

/**
 * TableAccessApi - object-oriented interface
 * @export
 * @class TableAccessApi
 * @extends {BaseAPI}
 */
export class TableAccessApi extends BaseAPI implements TableAccessApiInterface {
    /**
     * 
     * @summary Get Notebook
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} schemaName 
     * @param {string} cluster 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableAccessApi
     */
    public getNotebook(orgId: string, domainName: string, schemaName: string, cluster: string, tableName: string, options?: AxiosRequestConfig) {
        return TableAccessApiFp(this.configuration).getNotebook(orgId, domainName, schemaName, cluster, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Table Visualizations
     * @param {string} orgId 
     * @param {string} domainName 
     * @param {string} cluster 
     * @param {string} schemaName 
     * @param {string} tableName 
     * @param {TableVisualizationType} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableAccessApi
     */
    public getTableVisualizations(orgId: string, domainName: string, cluster: string, schemaName: string, tableName: string, type: TableVisualizationType, options?: AxiosRequestConfig) {
        return TableAccessApiFp(this.configuration).getTableVisualizations(orgId, domainName, cluster, schemaName, tableName, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add User
         * @param {string} orgId 
         * @param {AddUserRequest} addUserRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addUser: async (orgId: string, addUserRequest: AddUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addUser', 'orgId', orgId)
            // verify required parameter 'addUserRequest' is not null or undefined
            assertParamExists('addUser', 'addUserRequest', addUserRequest)
            const localVarPath = `/v1/org/{org_id}/user`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserResourceFollowed: async (resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('addUserResourceFollowed', 'resourceType', resourceType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserResourceFollowed', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addUserResourceFollowed', 'orgId', orgId)
            // verify required parameter 'resourceUri' is not null or undefined
            assertParamExists('addUserResourceFollowed', 'resourceUri', resourceUri)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}/follow/{resource_type}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (resourceUri !== undefined) {
                localVarQueryParameter['resource_uri'] = resourceUri;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserResourceOwned: async (resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('addUserResourceOwned', 'resourceType', resourceType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserResourceOwned', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addUserResourceOwned', 'orgId', orgId)
            // verify required parameter 'resourceUri' is not null or undefined
            assertParamExists('addUserResourceOwned', 'resourceUri', resourceUri)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}/own/{resource_type}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (resourceUri !== undefined) {
                localVarQueryParameter['resource_uri'] = resourceUri;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete User
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUser', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserResourceFollowed: async (resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('deleteUserResourceFollowed', 'resourceType', resourceType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserResourceFollowed', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUserResourceFollowed', 'orgId', orgId)
            // verify required parameter 'resourceUri' is not null or undefined
            assertParamExists('deleteUserResourceFollowed', 'resourceUri', resourceUri)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}/follow/{resource_type}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (resourceUri !== undefined) {
                localVarQueryParameter['resource_uri'] = resourceUri;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserResourceOwned: async (resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('deleteUserResourceOwned', 'resourceType', resourceType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserResourceOwned', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUserResourceOwned', 'orgId', orgId)
            // verify required parameter 'resourceUri' is not null or undefined
            assertParamExists('deleteUserResourceOwned', 'resourceUri', resourceUri)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}/own/{resource_type}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (resourceUri !== undefined) {
                localVarQueryParameter['resource_uri'] = resourceUri;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUser', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceFollowed: async (resourceType: ResourceType, userId: string, orgId: string, includeFavorites?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('getUserResourceFollowed', 'resourceType', resourceType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserResourceFollowed', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserResourceFollowed', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}/follow/{resource_type}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (includeFavorites !== undefined) {
                localVarQueryParameter['include_favorites'] = includeFavorites;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceOwned: async (resourceType: ResourceType, orgId: string, userId: string, includeFavorites?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('getUserResourceOwned', 'resourceType', resourceType)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserResourceOwned', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserResourceOwned', 'userId', userId)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}/own/{resource_type}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (includeFavorites !== undefined) {
                localVarQueryParameter['include_favorites'] = includeFavorites;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Resource Read
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceRead: async (resourceType: ResourceType, userId: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('getUserResourceRead', 'resourceType', resourceType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserResourceRead', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserResourceRead', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}/read/{resource_type}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite User
         * @param {string} orgId 
         * @param {InviteUserRequest} inviteUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: async (orgId: string, inviteUserRequest: InviteUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('inviteUser', 'orgId', orgId)
            // verify required parameter 'inviteUserRequest' is not null or undefined
            assertParamExists('inviteUser', 'inviteUserRequest', inviteUserRequest)
            const localVarPath = `/v1/org/{org_id}/user/invite`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users in Data Pipes catalog - **page_index** To list all results page_index should be -ve
         * @summary List Users
         * @param {string} orgId 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (orgId: string, pageIndex?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listUsers', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/user`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            if (pageIndex !== undefined) {
                localVarQueryParameter['page_index'] = pageIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke User Invite
         * @param {string} inviteCode 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserInvite: async (inviteCode: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteCode' is not null or undefined
            assertParamExists('revokeUserInvite', 'inviteCode', inviteCode)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('revokeUserInvite', 'orgId', orgId)
            const localVarPath = `/v1/org/{org_id}/user/invite/{invite_code}`
                .replace(`{${"invite_code"}}`, encodeURIComponent(String(inviteCode)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update User Role
         * @param {string} userId 
         * @param {string} orgId 
         * @param {UpdateUserRoleRequest} updateUserRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole: async (userId: string, orgId: string, updateUserRoleRequest: UpdateUserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRole', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateUserRole', 'orgId', orgId)
            // verify required parameter 'updateUserRoleRequest' is not null or undefined
            assertParamExists('updateUserRole', 'updateUserRoleRequest', updateUserRoleRequest)
            const localVarPath = `/v1/org/{org_id}/user/{user_id}/role`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify Invite Code
         * @param {string} inviteCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyInviteCode: async (inviteCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteCode' is not null or undefined
            assertParamExists('verifyInviteCode', 'inviteCode', inviteCode)
            const localVarPath = `/v1/invite/{invite_code}`
                .replace(`{${"invite_code"}}`, encodeURIComponent(String(inviteCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add User
         * @param {string} orgId 
         * @param {AddUserRequest} addUserRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async addUser(orgId: string, addUserRequest: AddUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUser(orgId, addUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRelationPutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserResourceFollowed(resourceType, userId, orgId, resourceUri, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserResourceOwned(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRelationPutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserResourceOwned(resourceType, userId, orgId, resourceUri, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete User
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRelationDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserResourceFollowed(resourceType, userId, orgId, resourceUri, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserResourceOwned(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRelationDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserResourceOwned(resourceType, userId, orgId, resourceUri, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, includeFavorites?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourceGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserResourceFollowed(resourceType, userId, orgId, includeFavorites, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserResourceOwned(resourceType: ResourceType, orgId: string, userId: string, includeFavorites?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourceGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserResourceOwned(resourceType, orgId, userId, includeFavorites, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User Resource Read
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserResourceRead(resourceType: ResourceType, userId: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourceGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserResourceRead(resourceType, userId, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invite User
         * @param {string} orgId 
         * @param {InviteUserRequest} inviteUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUser(orgId: string, inviteUserRequest: InviteUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(orgId, inviteUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List users in Data Pipes catalog - **page_index** To list all results page_index should be -ve
         * @summary List Users
         * @param {string} orgId 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(orgId: string, pageIndex?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(orgId, pageIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke User Invite
         * @param {string} inviteCode 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeUserInvite(inviteCode: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeUserInvite(inviteCode, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update User Role
         * @param {string} userId 
         * @param {string} orgId 
         * @param {UpdateUserRoleRequest} updateUserRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRole(userId: string, orgId: string, updateUserRoleRequest: UpdateUserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRole(userId, orgId, updateUserRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify Invite Code
         * @param {string} inviteCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyInviteCode(inviteCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyInviteCode(inviteCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Add User
         * @param {string} orgId 
         * @param {AddUserRequest} addUserRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addUser(orgId: string, addUserRequest: AddUserRequest, options?: any): AxiosPromise<AddUserResponse> {
            return localVarFp.addUser(orgId, addUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: any): AxiosPromise<UserRelationPutResponse> {
            return localVarFp.addUserResourceFollowed(resourceType, userId, orgId, resourceUri, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserResourceOwned(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: any): AxiosPromise<UserRelationPutResponse> {
            return localVarFp.addUserResourceOwned(resourceType, userId, orgId, resourceUri, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete User
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, orgId: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteUser(userId, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: any): AxiosPromise<UserRelationDeleteResponse> {
            return localVarFp.deleteUserResourceFollowed(resourceType, userId, orgId, resourceUri, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {string} resourceUri 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserResourceOwned(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: any): AxiosPromise<UserRelationDeleteResponse> {
            return localVarFp.deleteUserResourceOwned(resourceType, userId, orgId, resourceUri, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<UserProfileResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, orgId: string, options?: any): AxiosPromise<UserGetResponse> {
            return localVarFp.getUser(userId, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Resource Followed
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, includeFavorites?: boolean, options?: any): AxiosPromise<UserResourceGetResponse> {
            return localVarFp.getUserResourceFollowed(resourceType, userId, orgId, includeFavorites, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Resource Owned
         * @param {ResourceType} resourceType 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {boolean} [includeFavorites] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceOwned(resourceType: ResourceType, orgId: string, userId: string, includeFavorites?: boolean, options?: any): AxiosPromise<UserResourceGetResponse> {
            return localVarFp.getUserResourceOwned(resourceType, orgId, userId, includeFavorites, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Resource Read
         * @param {ResourceType} resourceType 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceRead(resourceType: ResourceType, userId: string, orgId: string, options?: any): AxiosPromise<UserResourceGetResponse> {
            return localVarFp.getUserResourceRead(resourceType, userId, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite User
         * @param {string} orgId 
         * @param {InviteUserRequest} inviteUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser(orgId: string, inviteUserRequest: InviteUserRequest, options?: any): AxiosPromise<any> {
            return localVarFp.inviteUser(orgId, inviteUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List users in Data Pipes catalog - **page_index** To list all results page_index should be -ve
         * @summary List Users
         * @param {string} orgId 
         * @param {number} [pageIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(orgId: string, pageIndex?: number, options?: any): AxiosPromise<ListUsersResponse> {
            return localVarFp.listUsers(orgId, pageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke User Invite
         * @param {string} inviteCode 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserInvite(inviteCode: string, orgId: string, options?: any): AxiosPromise<any> {
            return localVarFp.revokeUserInvite(inviteCode, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update User Role
         * @param {string} userId 
         * @param {string} orgId 
         * @param {UpdateUserRoleRequest} updateUserRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole(userId: string, orgId: string, updateUserRoleRequest: UpdateUserRoleRequest, options?: any): AxiosPromise<UserGetResponse> {
            return localVarFp.updateUserRole(userId, orgId, updateUserRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify Invite Code
         * @param {string} inviteCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyInviteCode(inviteCode: string, options?: any): AxiosPromise<any> {
            return localVarFp.verifyInviteCode(inviteCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @summary Add User
     * @param {string} orgId 
     * @param {AddUserRequest} addUserRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    addUser(orgId: string, addUserRequest: AddUserRequest, options?: AxiosRequestConfig): AxiosPromise<AddUserResponse>;

    /**
     * 
     * @summary Add User Resource Followed
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} resourceUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    addUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig): AxiosPromise<UserRelationPutResponse>;

    /**
     * 
     * @summary Add User Resource Owned
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} resourceUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    addUserResourceOwned(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig): AxiosPromise<UserRelationPutResponse>;

    /**
     * 
     * @summary Delete User
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUser(userId: string, orgId: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Delete User Resource Followed
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} resourceUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig): AxiosPromise<UserRelationDeleteResponse>;

    /**
     * 
     * @summary Delete User Resource Owned
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} resourceUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserResourceOwned(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig): AxiosPromise<UserRelationDeleteResponse>;

    /**
     * 
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getCurrentUser(options?: AxiosRequestConfig): AxiosPromise<UserProfileResponse>;

    /**
     * 
     * @summary Get User
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUser(userId: string, orgId: string, options?: AxiosRequestConfig): AxiosPromise<UserGetResponse>;

    /**
     * 
     * @summary Get User Resource Followed
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {boolean} [includeFavorites] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, includeFavorites?: boolean, options?: AxiosRequestConfig): AxiosPromise<UserResourceGetResponse>;

    /**
     * 
     * @summary Get User Resource Owned
     * @param {ResourceType} resourceType 
     * @param {string} orgId 
     * @param {string} userId 
     * @param {boolean} [includeFavorites] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserResourceOwned(resourceType: ResourceType, orgId: string, userId: string, includeFavorites?: boolean, options?: AxiosRequestConfig): AxiosPromise<UserResourceGetResponse>;

    /**
     * 
     * @summary Get User Resource Read
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserResourceRead(resourceType: ResourceType, userId: string, orgId: string, options?: AxiosRequestConfig): AxiosPromise<UserResourceGetResponse>;

    /**
     * 
     * @summary Invite User
     * @param {string} orgId 
     * @param {InviteUserRequest} inviteUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    inviteUser(orgId: string, inviteUserRequest: InviteUserRequest, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * List users in Data Pipes catalog - **page_index** To list all results page_index should be -ve
     * @summary List Users
     * @param {string} orgId 
     * @param {number} [pageIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listUsers(orgId: string, pageIndex?: number, options?: AxiosRequestConfig): AxiosPromise<ListUsersResponse>;

    /**
     * 
     * @summary Revoke User Invite
     * @param {string} inviteCode 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    revokeUserInvite(inviteCode: string, orgId: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Update User Role
     * @param {string} userId 
     * @param {string} orgId 
     * @param {UpdateUserRoleRequest} updateUserRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserRole(userId: string, orgId: string, updateUserRoleRequest: UpdateUserRoleRequest, options?: AxiosRequestConfig): AxiosPromise<UserGetResponse>;

    /**
     * 
     * @summary Verify Invite Code
     * @param {string} inviteCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    verifyInviteCode(inviteCode: string, options?: AxiosRequestConfig): AxiosPromise<any>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @summary Add User
     * @param {string} orgId 
     * @param {AddUserRequest} addUserRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUser(orgId: string, addUserRequest: AddUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).addUser(orgId, addUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add User Resource Followed
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} resourceUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).addUserResourceFollowed(resourceType, userId, orgId, resourceUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add User Resource Owned
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} resourceUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserResourceOwned(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).addUserResourceOwned(resourceType, userId, orgId, resourceUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete User
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: string, orgId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(userId, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete User Resource Followed
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} resourceUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUserResourceFollowed(resourceType, userId, orgId, resourceUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete User Resource Owned
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {string} resourceUri 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserResourceOwned(resourceType: ResourceType, userId: string, orgId: string, resourceUri: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUserResourceOwned(resourceType, userId, orgId, resourceUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, orgId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Resource Followed
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {boolean} [includeFavorites] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserResourceFollowed(resourceType: ResourceType, userId: string, orgId: string, includeFavorites?: boolean, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserResourceFollowed(resourceType, userId, orgId, includeFavorites, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Resource Owned
     * @param {ResourceType} resourceType 
     * @param {string} orgId 
     * @param {string} userId 
     * @param {boolean} [includeFavorites] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserResourceOwned(resourceType: ResourceType, orgId: string, userId: string, includeFavorites?: boolean, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserResourceOwned(resourceType, orgId, userId, includeFavorites, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Resource Read
     * @param {ResourceType} resourceType 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserResourceRead(resourceType: ResourceType, userId: string, orgId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserResourceRead(resourceType, userId, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite User
     * @param {string} orgId 
     * @param {InviteUserRequest} inviteUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public inviteUser(orgId: string, inviteUserRequest: InviteUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).inviteUser(orgId, inviteUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List users in Data Pipes catalog - **page_index** To list all results page_index should be -ve
     * @summary List Users
     * @param {string} orgId 
     * @param {number} [pageIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUsers(orgId: string, pageIndex?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUsers(orgId, pageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke User Invite
     * @param {string} inviteCode 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public revokeUserInvite(inviteCode: string, orgId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).revokeUserInvite(inviteCode, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update User Role
     * @param {string} userId 
     * @param {string} orgId 
     * @param {UpdateUserRoleRequest} updateUserRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserRole(userId: string, orgId: string, updateUserRoleRequest: UpdateUserRoleRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserRole(userId, orgId, updateUserRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify Invite Code
     * @param {string} inviteCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyInviteCode(inviteCode: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).verifyInviteCode(inviteCode, options).then((request) => request(this.axios, this.basePath));
    }
}


